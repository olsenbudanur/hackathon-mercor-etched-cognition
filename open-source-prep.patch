diff --git a/.dockerignore b/.dockerignore
new file mode 100644
index 0000000..3d9447a
--- /dev/null
+++ b/.dockerignore
@@ -0,0 +1,67 @@
+# Git
+.git
+.gitignore
+
+# Python
+__pycache__/
+*.py[cod]
+*$py.class
+*.so
+.Python
+env/
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+*.egg-info/
+.installed.cfg
+*.egg
+.pytest_cache/
+venv/
+.venv/
+
+# Node.js
+node_modules/
+npm-debug.log
+yarn-debug.log
+yarn-error.log
+
+# IDE
+.idea/
+.vscode/
+*.swp
+*.swo
+
+# OS
+.DS_Store
+Thumbs.db
+
+# Project specific
+*.log
+*.sqlite
+*.db
+.env
+.env.local
+.env.development.local
+.env.test.local
+.env.production.local
+
+# Docker
+.dockerignore
+Dockerfile
+docker-compose.yml
+
+# Documentation
+README.md
+LICENSE
+CHANGELOG.md
+
+# Tests
+tests/
diff --git a/CHANGELOG.md b/CHANGELOG.md
new file mode 100644
index 0000000..9821a72
--- /dev/null
+++ b/CHANGELOG.md
@@ -0,0 +1,29 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [0.1.0] - 2025-03-02
+
+### Added
+- Initial release
+- EEG-Enhanced Language Model with Mixture-of-Experts
+- FastAPI backend for token streaming
+- React frontend for visualization
+- EEG processing scripts
+- Kevin-MOE demo implementation
+- Comprehensive documentation
+- Unit and integration tests
+- Docker setup for easy deployment
+- Makefile for common development tasks
+
+### Changed
+- Renamed 'ecg' folder to 'eeg' for clarity
+- Restructured project for better organization
+- Enhanced code with comprehensive docstrings
+
+### Fixed
+- Initial code structure and organization
+- Documentation gaps and inconsistencies
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..d075f8c
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,53 @@
+# Multi-stage build for EEG-Enhanced Language Model with Mixture-of-Experts
+
+# Stage 1: Build the frontend
+FROM node:18-alpine AS frontend-build
+WORKDIR /app/frontend
+
+# Copy frontend package files and install dependencies
+COPY frontend/package*.json ./
+RUN npm install
+
+# Copy frontend source code and build
+COPY frontend/ ./
+RUN npm run build
+
+# Stage 2: Python base for backend and EEG processing
+FROM python:3.10-slim AS backend
+
+# Set working directory
+WORKDIR /app
+
+# Install system dependencies
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    build-essential \
+    && rm -rf /var/lib/apt/lists/*
+
+# Copy requirements and install Python dependencies
+COPY requirements.txt .
+RUN pip install --no-cache-dir -r requirements.txt
+
+# Copy the backend code
+COPY backend/ ./backend/
+COPY eeg/ ./eeg/
+COPY kevin-moe-demo/ ./kevin-moe-demo/
+
+# Copy frontend build from the frontend-build stage
+COPY --from=frontend-build /app/frontend/build ./frontend/build
+
+# Copy documentation
+COPY docs/ ./docs/
+
+# Copy setup files
+COPY setup.py .
+COPY README.md .
+COPY LICENSE .
+
+# Install the package
+RUN pip install -e .
+
+# Expose the port the app runs on
+EXPOSE 8000
+
+# Command to run the application
+CMD ["uvicorn", "backend.main:app", "--host", "0.0.0.0", "--port", "8000"]
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..b77bf2a
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2025
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/Makefile b/Makefile
new file mode 100644
index 0000000..cd2d382
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,104 @@
+.PHONY: setup backend frontend test clean docs venv
+
+# Variables
+VENV_NAME := venv
+PYTHON := python3
+PIP := pip3
+PYTEST := pytest
+UVICORN := uvicorn
+NPM := npm
+
+# Setup virtual environment and install dependencies
+setup: venv
+	@echo "Installing Python dependencies..."
+	$(VENV_NAME)/bin/$(PIP) install -r requirements.txt
+	@echo "Installing frontend dependencies..."
+	cd frontend && $(NPM) install
+
+# Create virtual environment
+venv:
+	@echo "Creating virtual environment..."
+	$(PYTHON) -m venv $(VENV_NAME)
+	@echo "Virtual environment created at $(VENV_NAME)/"
+
+# Run backend server
+backend:
+	@echo "Starting backend server..."
+	cd backend && $(VENV_NAME)/bin/$(UVICORN) main:app --reload --host 0.0.0.0 --port 8000
+
+# Run frontend application
+frontend:
+	@echo "Starting frontend application..."
+	cd frontend && $(NPM) start
+
+# Run tests
+test: test-backend test-eeg test-frontend test-integration
+
+# Run backend tests
+test-backend:
+	@echo "Running backend tests..."
+	$(VENV_NAME)/bin/$(PYTEST) tests/backend/
+
+# Run EEG tests
+test-eeg:
+	@echo "Running EEG tests..."
+	$(VENV_NAME)/bin/$(PYTEST) tests/eeg/
+
+# Run frontend tests
+test-frontend:
+	@echo "Running frontend tests..."
+	cd frontend && $(NPM) test
+
+# Run integration tests
+test-integration:
+	@echo "Running integration tests..."
+	$(VENV_NAME)/bin/$(PYTEST) tests/integration/
+
+# Run demo
+demo:
+	@echo "Running Kevin-MOE demo..."
+	$(VENV_NAME)/bin/$(PYTHON) kevin-moe-demo/demo.py
+
+# Build documentation
+docs:
+	@echo "Building documentation..."
+	@echo "Documentation is in markdown format in the docs/ directory"
+
+# Clean up temporary files
+clean:
+	@echo "Cleaning up temporary files..."
+	rm -rf __pycache__
+	rm -rf .pytest_cache
+	rm -rf frontend/node_modules
+	rm -rf $(VENV_NAME)
+	find . -type d -name "__pycache__" -exec rm -rf {} +
+	find . -type d -name "*.egg-info" -exec rm -rf {} +
+	find . -type f -name "*.pyc" -delete
+
+# Install package in development mode
+develop: venv
+	@echo "Installing package in development mode..."
+	$(VENV_NAME)/bin/$(PIP) install -e .
+
+# Package the project
+package: clean
+	@echo "Packaging the project..."
+	$(VENV_NAME)/bin/$(PYTHON) setup.py sdist bdist_wheel
+
+# Help command
+help:
+	@echo "Available commands:"
+	@echo "  setup         - Set up virtual environment and install dependencies"
+	@echo "  backend       - Run the backend server"
+	@echo "  frontend      - Run the frontend application"
+	@echo "  test          - Run all tests"
+	@echo "  test-backend  - Run backend tests"
+	@echo "  test-eeg      - Run EEG tests"
+	@echo "  test-frontend - Run frontend tests"
+	@echo "  test-integration - Run integration tests"
+	@echo "  demo          - Run the Kevin-MOE demo"
+	@echo "  docs          - Build documentation"
+	@echo "  clean         - Clean up temporary files"
+	@echo "  develop       - Install package in development mode"
+	@echo "  package       - Package the project"
+	@echo "  help          - Show this help message"
diff --git a/README.md b/README.md
index 7d9c4b7..1910a94 100644
--- a/README.md
+++ b/README.md
@@ -1,12 +1,182 @@
-# hackathon-mercor-etched-cognition
+# EEG-Enhanced Language Model with Mixture-of-Experts
 
+[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
 
+This project implements a brain-computer interface that enhances language model generation based on real-time EEG signals. The system uses a Mixture-of-Experts (MoE) approach to dynamically adapt the model's output based on detected attention levels.
 
-backend Fast API: <br>
-`pip3 install fastapi uvicorn` <br>
-`uvicorn main:app --reload`
+## üìë Overview
 
+This is an innovative brain-computer interface that enhances large language models by adapting their responses based on real-time EEG attention signals. The system uses a Mixture-of-Experts (MoE) approach to dynamically adjust the language model's generation process according to the user's cognitive state.
 
-react app: <br>
-`npm install` <br>
-`npm start`
+## üß† Key Features
+
+- **Real-time EEG signal processing** - Processes brain signals to extract attention levels
+- **Adaptive Language Model Generation** - Dynamically adjusts text generation based on attention levels
+- **Mixture-of-Experts Controller** - Routes generation through different "expert" configurations based on cognitive state
+- **Interactive Visualization** - Real-time visualization of attention levels and expert routing
+- **Flexible Architecture** - Works with both simulated and real EEG data from Muse headsets
+
+## üî¨ How It Works
+
+The system consists of four main components:
+
+1. **Backend (FastAPI)**: Handles token streaming and expert routing
+2. **Frontend (React)**: Visualizes the streamed tokens with different colors based on the expert
+3. **EEG Processing**: Processes EEG signals to extract attention metrics
+4. **Kevin-MOE Demo**: Implements the EEG-Enhanced Language Model with Mixture-of-Experts
+
+During text generation, the system continuously monitors attention levels and adjusts generation parameters, including:
+- Temperature (higher for low attention, lower for high attention)
+- Top-k sampling parameters
+- Repetition penalties
+- Token biasing toward common or rare vocabulary
+- Introduction of style tokens that match the cognitive state
+
+## üìÇ Repository Structure
+
+```
+hackathon-mercor-etched-cognition/
+‚îú‚îÄ‚îÄ backend/                # FastAPI backend for token streaming
+‚îÇ   ‚îî‚îÄ‚îÄ main.py             # Main FastAPI application
+‚îú‚îÄ‚îÄ frontend/               # React frontend for visualization
+‚îÇ   ‚îú‚îÄ‚îÄ public/             # Public assets
+‚îÇ   ‚îú‚îÄ‚îÄ src/                # React source code
+‚îÇ   ‚îî‚îÄ‚îÄ package.json        # Frontend dependencies
+‚îú‚îÄ‚îÄ eeg/                    # EEG processing scripts
+‚îÇ   ‚îú‚îÄ‚îÄ eeg.ipynb           # Jupyter notebook for EEG processing
+‚îÇ   ‚îî‚îÄ‚îÄ eeg.py              # Python script for EEG processing
+‚îú‚îÄ‚îÄ kevin-moe-demo/         # Kevin-MOE demo implementation
+‚îÇ   ‚îú‚îÄ‚îÄ main_eeg.py         # Core EEG-enhanced LLM implementation
+‚îÇ   ‚îú‚îÄ‚îÄ eeg_processor.py    # EEG signal processing module
+‚îÇ   ‚îú‚îÄ‚îÄ moe_control.py      # Mixture-of-Experts controller
+‚îÇ   ‚îî‚îÄ‚îÄ demo.py             # Interactive demonstration script
+‚îú‚îÄ‚îÄ tests/                  # Test suite
+‚îÇ   ‚îú‚îÄ‚îÄ backend/            # Backend tests
+‚îÇ   ‚îú‚îÄ‚îÄ eeg/                # EEG processing tests
+‚îÇ   ‚îú‚îÄ‚îÄ frontend/           # Frontend tests
+‚îÇ   ‚îî‚îÄ‚îÄ integration/        # Integration tests
+‚îú‚îÄ‚îÄ docs/                   # Documentation
+‚îÇ   ‚îú‚îÄ‚îÄ installation.md     # Installation instructions
+‚îÇ   ‚îú‚îÄ‚îÄ usage.md            # Usage instructions
+‚îÇ   ‚îú‚îÄ‚îÄ api.md              # API documentation
+‚îÇ   ‚îú‚îÄ‚îÄ contributing.md     # Contributing guidelines
+‚îÇ   ‚îî‚îÄ‚îÄ technical_approach.md # Technical approach documentation
+‚îú‚îÄ‚îÄ LICENSE                 # MIT License
+‚îú‚îÄ‚îÄ README.md               # This file
+‚îú‚îÄ‚îÄ requirements.txt        # Python dependencies
+‚îú‚îÄ‚îÄ setup.py                # Package installation
+‚îú‚îÄ‚îÄ Makefile                # Common tasks
+‚îú‚îÄ‚îÄ Dockerfile              # Docker configuration
+‚îî‚îÄ‚îÄ docker-compose.yml      # Docker Compose configuration
+```
+
+## üõ†Ô∏è Installation
+
+See [Installation Guide](docs/installation.md) for detailed instructions.
+
+### Quick Start
+
+1. Clone the repository:
+```bash
+git clone https://github.com/yourusername/hackathon-mercor-etched-cognition.git
+cd hackathon-mercor-etched-cognition
+```
+
+2. Install backend dependencies:
+```bash
+pip3 install fastapi uvicorn
+pip3 install -r requirements.txt
+```
+
+3. Install frontend dependencies:
+```bash
+cd frontend
+npm install
+cd ..
+```
+
+4. Start the backend:
+```bash
+cd backend
+uvicorn main:app --reload
+```
+
+5. Start the frontend (in a new terminal):
+```bash
+cd frontend
+npm start
+```
+
+## üéÆ Usage
+
+See [Usage Guide](docs/usage.md) for detailed instructions.
+
+### Basic Demo
+
+```bash
+cd kevin-moe-demo
+python3 demo.py
+```
+
+### Using Real EEG Data
+
+```bash
+cd kevin-moe-demo
+python3 demo.py --real-eeg
+```
+
+## üìä Technical Approaches
+
+See [Technical Approach](docs/technical_approach.md) for detailed information.
+
+### EEG Signal Processing
+
+The system extracts attention metrics by analyzing the balance between alpha (8-13 Hz) and beta (13-30 Hz) waves. Higher beta/alpha ratio generally indicates higher cognitive engagement.
+
+### Mixture-of-Experts Controller
+
+The MoE controller implements three expert configurations:
+
+1. **Simplicity Expert (Low Attention)**
+   - Higher temperature for more varied, simpler outputs
+   - Lower top-k to focus on common tokens
+   - Boosts frequency of common words and simplifying phrases
+
+2. **Balanced Expert (Medium Attention)**
+   - Moderate temperature
+   - Moderate top-k
+   - Balanced token distribution without strong biasing
+
+3. **Complexity Expert (High Attention)**
+   - Lower temperature for more deterministic, focused outputs
+   - Higher top-k allowing for more specialized tokens
+   - Boosts frequency of rare/technical tokens and complex phrases
+
+### Token Streaming
+
+The system implements token-by-token generation with EEG-based steering:
+
+1. For each generation step, the current attention level is sampled
+2. MoE controller weights are updated based on attention
+3. Logits from the language model are modified according to expert weights
+4. Temperature and sampling parameters are dynamically adjusted
+5. Generation statistics are tracked for analysis
+
+## üß™ Testing
+
+```bash
+pytest tests/
+```
+
+## ü§ù Contributing
+
+We welcome contributions! Please see our [Contributing Guidelines](docs/contributing.md) for more information.
+
+## üìÑ License
+
+This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
+
+## üôè Acknowledgements
+
+- The open-source NLP and BCI communities
+- Contributors to the FastAPI, React, and PyTorch ecosystems
diff --git a/backend/main.py b/backend/main.py
index b535956..9d934a0 100644
--- a/backend/main.py
+++ b/backend/main.py
@@ -1,3 +1,14 @@
+"""
+FastAPI Backend for EEG-Enhanced Language Model with Mixture-of-Experts
+
+This module implements a FastAPI backend that handles token streaming from the EEG-enhanced
+language model to the frontend. It provides endpoints for adding tokens, streaming tokens,
+clearing the token queue, toggling test data generation, and getting server status.
+
+The backend serves as a bridge between the EEG processing and language model components
+and the frontend visualization.
+"""
+
 from fastapi import FastAPI
 from fastapi.responses import StreamingResponse
 from fastapi import Body, HTTPException
@@ -11,8 +22,14 @@ import asyncio
 from collections import deque
 from pydantic import BaseModel
 
-app = FastAPI()
+# Initialize FastAPI application
+app = FastAPI(
+    title="EEG-Enhanced LM Backend",
+    description="Backend for EEG-Enhanced Language Model with Mixture-of-Experts",
+    version="0.1.0"
+)
 
+# Configure CORS middleware
 app.add_middleware(
     CORSMiddleware,
     allow_origins=["http://localhost:3000"],  # Allow requests from the frontend
@@ -36,17 +53,74 @@ EXPERT_COLORS = {
 }
 
 class TokenData(BaseModel):
+    """
+    Pydantic model for a single token with its associated expert.
+    
+    Attributes:
+        token (str): The text token generated by the language model
+        expert (str): The expert that generated this token (simple, balanced, or complex)
+    
+    Example:
+        ```python
+        token_data = TokenData(token="hello", expert="simple")
+        ```
+    """
     token: str
     expert: str
 
 class TokenStreamData(BaseModel):
+    """
+    Pydantic model for a stream of tokens with their associated experts.
+    
+    Attributes:
+        tokens (List[TokenData]): List of TokenData objects containing tokens and their experts
+    
+    Example:
+        ```python
+        stream_data = TokenStreamData(tokens=[
+            TokenData(token="hello", expert="simple"),
+            TokenData(token=" ", expert="balanced"),
+            TokenData(token="world", expert="complex")
+        ])
+        ```
+    """
     tokens: List[TokenData]
 
 @app.post("/add-tokens")
 async def add_tokens(data: TokenStreamData):
     """
-    Endpoint to receive token data from the EEG demo
-    and add it to the streaming queue
+    Endpoint to receive token data from the EEG demo and add it to the streaming queue.
+    
+    This endpoint receives tokens generated by the language model along with their
+    associated experts, processes them, and adds them to the token queue for streaming
+    to the frontend.
+    
+    Args:
+        data (TokenStreamData): A TokenStreamData object containing a list of tokens
+                               and their associated experts
+    
+    Returns:
+        dict: A dictionary with status information and the number of tokens added
+              - status (str): "success" if tokens were added successfully
+              - tokens_added (int): The number of tokens that were added to the queue
+    
+    Example:
+        ```python
+        import requests
+        import json
+        
+        response = requests.post(
+            "http://localhost:8000/add-tokens",
+            json={
+                "tokens": [
+                    {"token": "Hello", "expert": "simple"},
+                    {"token": " ", "expert": "balanced"},
+                    {"token": "world", "expert": "complex"}
+                ]
+            }
+        )
+        print(response.json())  # {"status": "success", "tokens_added": 3}
+        ```
     """
     for token_data in data.tokens:
         # Add each token with its expert to the queue
@@ -78,8 +152,23 @@ async def add_tokens(data: TokenStreamData):
 # Fallback function for demo/testing - generates random words
 def generate_random_token():
     """
-    Generate a random token with an associated expert.
-    Creates more realistic token samples than just random letters.
+    Generate a random token with an associated expert for testing purposes.
+    
+    This function creates realistic token samples for testing the frontend visualization
+    when no real EEG data is available. It generates different types of tokens (words,
+    punctuation, spaces, abbreviations, numbers) with appropriate expert assignments
+    based on token characteristics.
+    
+    Returns:
+        dict: A dictionary containing the generated token and its associated expert color
+              - word (str): The generated token text
+              - number (int): The color number corresponding to the expert (1-3)
+    
+    Example:
+        ```python
+        token = generate_random_token()
+        print(token)  # {'word': 'the', 'number': 1}
+        ```
     """
     # Possible token types
     token_types = [
@@ -164,8 +253,23 @@ def generate_random_token():
 # Streaming function to yield tokens from the queue
 async def event_stream():
     """
-    Stream tokens to the frontend in a controlled manner.
-    Handles both real tokens from queue and random test tokens when enabled.
+    Stream tokens to the frontend in a controlled manner using server-sent events.
+    
+    This asynchronous generator function continuously streams tokens from the token queue
+    to the frontend. If the queue is empty and test data generation is enabled, it will
+    generate random test tokens. The function includes realistic delays between tokens
+    to simulate the natural rhythm of text generation.
+    
+    Yields:
+        str: Server-sent event formatted string containing token data in JSON format
+    
+    Example:
+        This function is typically used with FastAPI's StreamingResponse:
+        ```python
+        @app.get("/stream")
+        async def stream():
+            return StreamingResponse(event_stream(), media_type="text/event-stream")
+        ```
     """
     while True:
         if token_queue:
@@ -205,19 +309,80 @@ async def event_stream():
 
 @app.get("/stream")
 async def stream():
-    """Stream tokens to the frontend"""
+    """
+    Stream tokens to the frontend using server-sent events.
+    
+    This endpoint establishes a persistent connection with the frontend and
+    streams tokens one by one as they become available in the token queue.
+    
+    Returns:
+        StreamingResponse: A streaming response that yields tokens as server-sent events
+    
+    Example:
+        This endpoint is typically consumed by an EventSource in JavaScript:
+        ```javascript
+        const eventSource = new EventSource('/stream');
+        eventSource.onmessage = (event) => {
+            const data = JSON.parse(event.data);
+            console.log('Received token:', data.word, 'Expert:', data.number);
+        };
+        ```
+    """
     return StreamingResponse(event_stream(), media_type="text/event-stream")
 
 # Endpoint to clear the token queue (useful for testing)
 @app.post("/clear-tokens")
 async def clear_tokens():
+    """
+    Clear all tokens from the token queue.
+    
+    This endpoint is useful for testing and resetting the state of the application.
+    
+    Returns:
+        dict: A dictionary with status information
+              - status (str): "success" if the queue was cleared successfully
+              - message (str): A message indicating that the token queue was cleared
+    
+    Example:
+        ```python
+        import requests
+        
+        response = requests.post("http://localhost:8000/clear-tokens")
+        print(response.json())  # {"status": "success", "message": "Token queue cleared"}
+        ```
+    """
     token_queue.clear()
     return {"status": "success", "message": "Token queue cleared"}
 
 # Endpoint to toggle test data generation
 @app.post("/toggle-test-data")
 async def toggle_test_data(enable: bool = Body(..., embed=True)):
-    """Enable or disable random test data generation"""
+    """
+    Enable or disable random test data generation.
+    
+    When test data generation is enabled, the server will generate random tokens
+    when the token queue is empty, which is useful for testing the frontend
+    without real EEG data.
+    
+    Args:
+        enable (bool): Whether to enable (True) or disable (False) test data generation
+    
+    Returns:
+        dict: A dictionary with status information
+              - status (str): "success" if the setting was updated successfully
+              - test_data_enabled (bool): The current state of test data generation
+    
+    Example:
+        ```python
+        import requests
+        
+        response = requests.post(
+            "http://localhost:8000/toggle-test-data",
+            json={"enable": True}
+        )
+        print(response.json())  # {"status": "success", "test_data_enabled": true}
+        ```
+    """
     global enable_test_data
     enable_test_data = enable
     return {"status": "success", "test_data_enabled": enable_test_data}
@@ -225,7 +390,26 @@ async def toggle_test_data(enable: bool = Body(..., embed=True)):
 # Get current status
 @app.get("/status")
 async def get_status():
-    """Get the current status of the server"""
+    """
+    Get the current status of the server.
+    
+    This endpoint returns information about the current state of the server,
+    including the number of tokens in the queue and whether test data generation
+    is enabled.
+    
+    Returns:
+        dict: A dictionary with status information
+              - queue_size (int): The number of tokens currently in the queue
+              - test_data_enabled (bool): Whether test data generation is enabled
+    
+    Example:
+        ```python
+        import requests
+        
+        response = requests.get("http://localhost:8000/status")
+        print(response.json())  # {"queue_size": 10, "test_data_enabled": false}
+        ```
+    """
     return {
         "queue_size": len(token_queue),
         "test_data_enabled": enable_test_data
@@ -235,10 +419,32 @@ async def get_status():
 @app.get("/debug-tokens")
 async def debug_tokens(limit: int = 50):
     """
-    Get a dump of recently processed tokens for debugging
+    Get a dump of recently processed tokens for debugging purposes.
+    
+    This endpoint returns a list of tokens currently in the queue, which is useful
+    for debugging and monitoring the state of the application.
     
     Args:
-        limit: Maximum number of tokens to return (default 50)
+        limit (int, optional): Maximum number of tokens to return. Defaults to 50.
+    
+    Returns:
+        dict: A dictionary with debug information
+              - queue_size (int): The number of tokens currently in the queue
+              - tokens (list): A list of token dictionaries, limited by the limit parameter
+              - test_data_enabled (bool): Whether test data generation is enabled
+    
+    Example:
+        ```python
+        import requests
+        
+        response = requests.get("http://localhost:8000/debug-tokens?limit=10")
+        print(response.json())
+        # {
+        #   "queue_size": 15,
+        #   "tokens": [{"word": "Hello", "number": 1}, ...],
+        #   "test_data_enabled": false
+        # }
+        ```
     """
     # Create a copy of the token queue for inspection
     token_list = list(token_queue)
@@ -252,12 +458,33 @@ async def debug_tokens(limit: int = 50):
 # Set debug mode on startup (but not test data by default)
 @app.on_event("startup")
 async def startup_event():
+    """
+    Initialize the application on startup.
+    
+    This function is called when the FastAPI application starts up. It sets
+    the debug mode and initializes the test data generation flag.
+    """
     app.debug = True  # Set to False in production
     global enable_test_data
     enable_test_data = False
 
 def generate_test_tokens():
-    """Generate random test tokens for development"""
+    """
+    Generate random test tokens for development and testing.
+    
+    This function creates a list of random tokens with associated experts for
+    testing the token streaming functionality without real EEG data.
+    
+    Returns:
+        list: A list of TokenData objects containing random tokens and experts
+    
+    Example:
+        ```python
+        tokens = generate_test_tokens()
+        for token in tokens:
+            print(f"Token: {token.token}, Expert: {token.expert}")
+        ```
+    """
     words = ["The", "quick", "brown", "fox", "jumps", "over", "lazy", "dog", 
              "Hello", "world", "This", "is", "a", "test", "of", "token", "streaming",
              "with", "different", "experts", "handling", "various", "parts", 
@@ -277,6 +504,6 @@ def generate_test_tokens():
             text = random.choice(words)
             
         expert = random.choice(experts)
-        tokens.append(Token(text=text, expert=expert))
+        tokens.append(TokenData(token=text, expert=expert))
         
     return tokens
diff --git a/docker-compose.yml b/docker-compose.yml
new file mode 100644
index 0000000..8c649e9
--- /dev/null
+++ b/docker-compose.yml
@@ -0,0 +1,54 @@
+version: '3.8'
+
+services:
+  # Backend service
+  backend:
+    build:
+      context: .
+      dockerfile: Dockerfile
+    ports:
+      - "8000:8000"
+    volumes:
+      - ./backend:/app/backend
+      - ./eeg:/app/eeg
+    environment:
+      - PYTHONUNBUFFERED=1
+    command: uvicorn backend.main:app --host 0.0.0.0 --port 8000 --reload
+    networks:
+      - eeg-network
+
+  # Frontend service
+  frontend:
+    image: node:18-alpine
+    working_dir: /app
+    volumes:
+      - ./frontend:/app
+    ports:
+      - "3000:3000"
+    environment:
+      - NODE_ENV=development
+      - REACT_APP_BACKEND_URL=http://localhost:8000
+    command: sh -c "npm install && npm start"
+    depends_on:
+      - backend
+    networks:
+      - eeg-network
+
+  # Demo service (optional)
+  demo:
+    build:
+      context: .
+      dockerfile: Dockerfile
+    volumes:
+      - ./kevin-moe-demo:/app/kevin-moe-demo
+    environment:
+      - PYTHONUNBUFFERED=1
+    command: python kevin-moe-demo/demo.py
+    depends_on:
+      - backend
+    networks:
+      - eeg-network
+
+networks:
+  eeg-network:
+    driver: bridge
diff --git a/docs/api.md b/docs/api.md
new file mode 100644
index 0000000..d1a80ff
--- /dev/null
+++ b/docs/api.md
@@ -0,0 +1,487 @@
+# API Documentation
+
+This document provides detailed information about the API endpoints available in the EEG-Enhanced Language Model with Mixture-of-Experts project. The backend is built with FastAPI and provides several endpoints for token streaming, status monitoring, and debugging.
+
+## Table of Contents
+
+- [Base URL](#base-url)
+- [Authentication](#authentication)
+- [Endpoints](#endpoints)
+  - [Add Tokens](#add-tokens)
+  - [Stream Tokens](#stream-tokens)
+  - [Clear Tokens](#clear-tokens)
+  - [Toggle Test Data](#toggle-test-data)
+  - [Get Status](#get-status)
+  - [Debug Tokens](#debug-tokens)
+- [Data Models](#data-models)
+- [Error Handling](#error-handling)
+- [Rate Limiting](#rate-limiting)
+- [Examples](#examples)
+
+## Base URL
+
+All API endpoints are relative to the base URL:
+
+```
+http://localhost:8000
+```
+
+## Authentication
+
+The API does not currently require authentication. It is designed for local development and testing.
+
+## Endpoints
+
+### Add Tokens
+
+Adds tokens to the streaming queue.
+
+**URL**: `/add-tokens`
+
+**Method**: `POST`
+
+**Request Body**:
+
+```json
+{
+  "tokens": [
+    {
+      "token": "string",
+      "expert": "string"
+    }
+  ]
+}
+```
+
+**Parameters**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `tokens` | array | Array of token objects |
+| `tokens[].token` | string | The text token generated by the language model |
+| `tokens[].expert` | string | The expert that generated this token (simple, balanced, or complex) |
+
+**Response**:
+
+```json
+{
+  "status": "success",
+  "tokens_added": 3
+}
+```
+
+**Response Fields**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `status` | string | Status of the operation (success or error) |
+| `tokens_added` | integer | Number of tokens added to the queue |
+
+**Status Codes**:
+
+| Status Code | Description |
+|-------------|-------------|
+| 200 | Success |
+| 422 | Validation Error (invalid request body) |
+
+**Example**:
+
+```bash
+curl -X POST "http://localhost:8000/add-tokens" \
+     -H "Content-Type: application/json" \
+     -d '{
+           "tokens": [
+             {
+               "token": "Hello",
+               "expert": "simple"
+             },
+             {
+               "token": " ",
+               "expert": "balanced"
+             },
+             {
+               "token": "world",
+               "expert": "complex"
+             }
+           ]
+         }'
+```
+
+### Stream Tokens
+
+Streams tokens to the frontend using server-sent events.
+
+**URL**: `/stream`
+
+**Method**: `GET`
+
+**Response**: Server-sent events with token data.
+
+**Event Format**:
+
+```
+data: {"word": "Hello", "number": 1}
+```
+
+**Event Fields**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `word` | string | The text token |
+| `number` | integer | The color number corresponding to the expert (1-3) |
+
+**Status Codes**:
+
+| Status Code | Description |
+|-------------|-------------|
+| 200 | Success |
+
+**Example**:
+
+```javascript
+// JavaScript client code
+const eventSource = new EventSource('http://localhost:8000/stream');
+eventSource.onmessage = (event) => {
+  const data = JSON.parse(event.data);
+  console.log('Received token:', data.word, 'Expert color:', data.number);
+};
+```
+
+### Clear Tokens
+
+Clears all tokens from the token queue.
+
+**URL**: `/clear-tokens`
+
+**Method**: `POST`
+
+**Response**:
+
+```json
+{
+  "status": "success",
+  "message": "Token queue cleared"
+}
+```
+
+**Response Fields**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `status` | string | Status of the operation (success or error) |
+| `message` | string | Description of the operation result |
+
+**Status Codes**:
+
+| Status Code | Description |
+|-------------|-------------|
+| 200 | Success |
+
+**Example**:
+
+```bash
+curl -X POST "http://localhost:8000/clear-tokens"
+```
+
+### Toggle Test Data
+
+Enables or disables random test data generation.
+
+**URL**: `/toggle-test-data`
+
+**Method**: `POST`
+
+**Request Body**:
+
+```json
+{
+  "enable": true
+}
+```
+
+**Parameters**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `enable` | boolean | Whether to enable (true) or disable (false) test data generation |
+
+**Response**:
+
+```json
+{
+  "status": "success",
+  "test_data_enabled": true
+}
+```
+
+**Response Fields**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `status` | string | Status of the operation (success or error) |
+| `test_data_enabled` | boolean | Current state of test data generation |
+
+**Status Codes**:
+
+| Status Code | Description |
+|-------------|-------------|
+| 200 | Success |
+| 422 | Validation Error (invalid request body) |
+
+**Example**:
+
+```bash
+curl -X POST "http://localhost:8000/toggle-test-data" \
+     -H "Content-Type: application/json" \
+     -d '{"enable": true}'
+```
+
+### Get Status
+
+Gets the current status of the server.
+
+**URL**: `/status`
+
+**Method**: `GET`
+
+**Response**:
+
+```json
+{
+  "queue_size": 10,
+  "test_data_enabled": false
+}
+```
+
+**Response Fields**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `queue_size` | integer | Number of tokens currently in the queue |
+| `test_data_enabled` | boolean | Whether test data generation is enabled |
+
+**Status Codes**:
+
+| Status Code | Description |
+|-------------|-------------|
+| 200 | Success |
+
+**Example**:
+
+```bash
+curl -X GET "http://localhost:8000/status"
+```
+
+### Debug Tokens
+
+Gets a dump of recently processed tokens for debugging.
+
+**URL**: `/debug-tokens`
+
+**Method**: `GET`
+
+**Query Parameters**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `limit` | integer | Maximum number of tokens to return (default: 50) |
+
+**Response**:
+
+```json
+{
+  "queue_size": 15,
+  "tokens": [
+    {
+      "word": "Hello",
+      "number": 1
+    },
+    {
+      "word": " ",
+      "number": 2
+    },
+    {
+      "word": "world",
+      "number": 3
+    }
+  ],
+  "test_data_enabled": false
+}
+```
+
+**Response Fields**:
+
+| Name | Type | Description |
+|------|------|-------------|
+| `queue_size` | integer | Number of tokens currently in the queue |
+| `tokens` | array | Array of token objects |
+| `tokens[].word` | string | The text token |
+| `tokens[].number` | integer | The color number corresponding to the expert (1-3) |
+| `test_data_enabled` | boolean | Whether test data generation is enabled |
+
+**Status Codes**:
+
+| Status Code | Description |
+|-------------|-------------|
+| 200 | Success |
+
+**Example**:
+
+```bash
+curl -X GET "http://localhost:8000/debug-tokens?limit=10"
+```
+
+## Data Models
+
+### TokenData
+
+```json
+{
+  "token": "string",
+  "expert": "string"
+}
+```
+
+| Field | Type | Description |
+|-------|------|-------------|
+| `token` | string | The text token generated by the language model |
+| `expert` | string | The expert that generated this token (simple, balanced, or complex) |
+
+### TokenStreamData
+
+```json
+{
+  "tokens": [
+    {
+      "token": "string",
+      "expert": "string"
+    }
+  ]
+}
+```
+
+| Field | Type | Description |
+|-------|------|-------------|
+| `tokens` | array | Array of TokenData objects |
+
+## Error Handling
+
+The API uses standard HTTP status codes to indicate the success or failure of a request.
+
+### Common Error Codes
+
+| Status Code | Description |
+|-------------|-------------|
+| 400 | Bad Request - The request was malformed |
+| 404 | Not Found - The requested resource was not found |
+| 422 | Validation Error - The request body failed validation |
+| 500 | Internal Server Error - An unexpected error occurred |
+
+### Error Response Format
+
+```json
+{
+  "detail": [
+    {
+      "loc": ["body", "tokens", 0, "token"],
+      "msg": "field required",
+      "type": "value_error.missing"
+    }
+  ]
+}
+```
+
+## Rate Limiting
+
+The API does not currently implement rate limiting. It is designed for local development and testing.
+
+## Examples
+
+### Python Client Example
+
+```python
+import requests
+import json
+import sseclient
+
+# Add tokens to the queue
+def add_tokens(tokens):
+    response = requests.post(
+        "http://localhost:8000/add-tokens",
+        json={"tokens": tokens}
+    )
+    return response.json()
+
+# Stream tokens from the server
+def stream_tokens():
+    response = requests.get("http://localhost:8000/stream", stream=True)
+    client = sseclient.SSEClient(response)
+    for event in client.events():
+        yield json.loads(event.data)
+
+# Example usage
+tokens = [
+    {"token": "Hello", "expert": "simple"},
+    {"token": " ", "expert": "balanced"},
+    {"token": "world", "expert": "complex"}
+]
+
+# Add tokens
+result = add_tokens(tokens)
+print(f"Added {result['tokens_added']} tokens")
+
+# Stream tokens
+for token in stream_tokens():
+    print(f"Received token: {token['word']}, Expert: {token['number']}")
+    # Break after receiving 5 tokens
+    if token['word'] == "world":
+        break
+```
+
+### JavaScript Client Example
+
+```javascript
+// Add tokens to the queue
+async function addTokens(tokens) {
+  const response = await fetch('http://localhost:8000/add-tokens', {
+    method: 'POST',
+    headers: {
+      'Content-Type': 'application/json'
+    },
+    body: JSON.stringify({ tokens })
+  });
+  return response.json();
+}
+
+// Stream tokens from the server
+function streamTokens(callback) {
+  const eventSource = new EventSource('http://localhost:8000/stream');
+  eventSource.onmessage = (event) => {
+    const data = JSON.parse(event.data);
+    callback(data);
+  };
+  return eventSource;
+}
+
+// Example usage
+const tokens = [
+  { token: 'Hello', expert: 'simple' },
+  { token: ' ', expert: 'balanced' },
+  { token: 'world', expert: 'complex' }
+];
+
+// Add tokens
+addTokens(tokens)
+  .then(result => console.log(`Added ${result.tokens_added} tokens`))
+  .catch(error => console.error('Error adding tokens:', error));
+
+// Stream tokens
+const eventSource = streamTokens(data => {
+  console.log(`Received token: ${data.word}, Expert: ${data.number}`);
+  
+  // Close the connection after receiving the 'world' token
+  if (data.word === 'world') {
+    eventSource.close();
+  }
+});
+```
diff --git a/docs/contributing.md b/docs/contributing.md
new file mode 100644
index 0000000..17569dd
--- /dev/null
+++ b/docs/contributing.md
@@ -0,0 +1,314 @@
+# Contributing Guidelines
+
+Thank you for your interest in contributing to the EEG-Enhanced Language Model with Mixture-of-Experts project! This document provides guidelines and instructions for contributing to the project.
+
+## Table of Contents
+
+- [Code of Conduct](#code-of-conduct)
+- [Getting Started](#getting-started)
+  - [Setting Up the Development Environment](#setting-up-the-development-environment)
+  - [Project Structure](#project-structure)
+- [Development Workflow](#development-workflow)
+  - [Branching Strategy](#branching-strategy)
+  - [Commit Messages](#commit-messages)
+  - [Pull Requests](#pull-requests)
+- [Coding Standards](#coding-standards)
+  - [Python Code Style](#python-code-style)
+  - [JavaScript Code Style](#javascript-code-style)
+  - [Documentation Style](#documentation-style)
+- [Testing](#testing)
+  - [Running Tests](#running-tests)
+  - [Writing Tests](#writing-tests)
+- [Issue Reporting](#issue-reporting)
+- [Feature Requests](#feature-requests)
+- [Documentation](#documentation)
+- [Community](#community)
+
+## Code of Conduct
+
+Please read and follow our [Code of Conduct](CODE_OF_CONDUCT.md) to foster an open and welcoming environment.
+
+## Getting Started
+
+### Setting Up the Development Environment
+
+1. **Fork the repository**:
+   - Visit the [GitHub repository](https://github.com/yourusername/hackathon-mercor-etched-cognition)
+   - Click the "Fork" button in the top-right corner
+
+2. **Clone your fork**:
+   ```bash
+   git clone https://github.com/your-username/hackathon-mercor-etched-cognition.git
+   cd hackathon-mercor-etched-cognition
+   ```
+
+3. **Set up the upstream remote**:
+   ```bash
+   git remote add upstream https://github.com/yourusername/hackathon-mercor-etched-cognition.git
+   ```
+
+4. **Create a virtual environment**:
+   ```bash
+   python -m venv venv
+   source venv/bin/activate  # On Windows: venv\Scripts\activate
+   ```
+
+5. **Install dependencies**:
+   ```bash
+   pip install -r requirements.txt
+   pip install -e .  # Install the package in development mode
+   ```
+
+6. **Install frontend dependencies**:
+   ```bash
+   cd frontend
+   npm install
+   cd ..
+   ```
+
+### Project Structure
+
+The project is organized as follows:
+
+```
+hackathon-mercor-etched-cognition/
+‚îú‚îÄ‚îÄ backend/                # FastAPI backend for token streaming
+‚îÇ   ‚îî‚îÄ‚îÄ main.py             # Main FastAPI application
+‚îú‚îÄ‚îÄ frontend/               # React frontend for visualization
+‚îÇ   ‚îú‚îÄ‚îÄ public/             # Public assets
+‚îÇ   ‚îú‚îÄ‚îÄ src/                # React source code
+‚îÇ   ‚îî‚îÄ‚îÄ package.json        # Frontend dependencies
+‚îú‚îÄ‚îÄ eeg/                    # EEG processing scripts
+‚îÇ   ‚îú‚îÄ‚îÄ eeg.ipynb           # Jupyter notebook for EEG processing
+‚îÇ   ‚îî‚îÄ‚îÄ eeg.py              # Python script for EEG processing
+‚îú‚îÄ‚îÄ kevin-moe-demo/         # Kevin-MOE demo implementation
+‚îÇ   ‚îú‚îÄ‚îÄ main_eeg.py         # Core EEG-enhanced LLM implementation
+‚îÇ   ‚îú‚îÄ‚îÄ eeg_processor.py    # EEG signal processing module
+‚îÇ   ‚îú‚îÄ‚îÄ moe_control.py      # Mixture-of-Experts controller
+‚îÇ   ‚îî‚îÄ‚îÄ demo.py             # Interactive demonstration script
+‚îú‚îÄ‚îÄ tests/                  # Test suite
+‚îÇ   ‚îú‚îÄ‚îÄ backend/            # Backend tests
+‚îÇ   ‚îú‚îÄ‚îÄ eeg/                # EEG processing tests
+‚îÇ   ‚îú‚îÄ‚îÄ frontend/           # Frontend tests
+‚îÇ   ‚îî‚îÄ‚îÄ integration/        # Integration tests
+‚îú‚îÄ‚îÄ docs/                   # Documentation
+‚îú‚îÄ‚îÄ LICENSE                 # MIT License
+‚îú‚îÄ‚îÄ README.md               # Project overview
+‚îú‚îÄ‚îÄ requirements.txt        # Python dependencies
+‚îú‚îÄ‚îÄ setup.py                # Package installation
+‚îú‚îÄ‚îÄ Makefile                # Common tasks
+‚îî‚îÄ‚îÄ docker-compose.yml      # Docker Compose configuration
+```
+
+## Development Workflow
+
+### Branching Strategy
+
+We use a feature branch workflow:
+
+1. **Create a new branch for your feature or bugfix**:
+   ```bash
+   git checkout -b feature/your-feature-name
+   # or
+   git checkout -b fix/your-bugfix-name
+   ```
+
+2. **Keep your branch updated with upstream**:
+   ```bash
+   git fetch upstream
+   git rebase upstream/main
+   ```
+
+### Commit Messages
+
+Please follow these guidelines for commit messages:
+
+- Use the present tense ("Add feature" not "Added feature")
+- Use the imperative mood ("Move cursor to..." not "Moves cursor to...")
+- Limit the first line to 72 characters or less
+- Reference issues and pull requests liberally after the first line
+- Consider starting the commit message with an applicable emoji:
+  - üé® `:art:` when improving the format/structure of the code
+  - üêõ `:bug:` when fixing a bug
+  - üìö `:books:` when adding or updating documentation
+  - ‚ú® `:sparkles:` when adding a new feature
+  - üîß `:wrench:` when updating configuration files
+  - üß™ `:test_tube:` when adding tests
+
+Example:
+```
+‚ú® Add real-time EEG visualization component
+
+- Implement WebGL-based EEG signal visualization
+- Add frequency band power display
+- Connect to WebSocket for real-time updates
+
+Fixes #42
+```
+
+### Pull Requests
+
+1. **Push your changes to your fork**:
+   ```bash
+   git push origin feature/your-feature-name
+   ```
+
+2. **Create a pull request**:
+   - Go to your fork on GitHub
+   - Click "New Pull Request"
+   - Select your branch and the main repository's main branch
+   - Fill out the PR template with details about your changes
+
+3. **PR Review Process**:
+   - All PRs require at least one review from a maintainer
+   - Address any requested changes and push updates to your branch
+   - Once approved, a maintainer will merge your PR
+
+## Coding Standards
+
+### Python Code Style
+
+We follow [PEP 8](https://www.python.org/dev/peps/pep-0008/) for Python code style with the following additions:
+
+- Use 4 spaces for indentation (no tabs)
+- Maximum line length is 88 characters (following Black's default)
+- Use docstrings for all public modules, functions, classes, and methods
+- Use type hints where appropriate
+
+We use the following tools for code quality:
+- [Black](https://black.readthedocs.io/) for code formatting
+- [isort](https://pycqa.github.io/isort/) for import sorting
+- [flake8](https://flake8.pycqa.org/) for linting
+- [mypy](https://mypy.readthedocs.io/) for static type checking
+
+You can run these tools with:
+```bash
+# Format code
+black .
+isort .
+
+# Check code quality
+flake8
+mypy .
+```
+
+### JavaScript Code Style
+
+For JavaScript/React code, we follow the [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript) with the following additions:
+
+- Use 2 spaces for indentation
+- Use semicolons
+- Use single quotes for strings
+- Use ES6 features where appropriate
+- Use JSDoc comments for documentation
+
+We use the following tools for code quality:
+- [ESLint](https://eslint.org/) for linting
+- [Prettier](https://prettier.io/) for code formatting
+
+You can run these tools with:
+```bash
+cd frontend
+npm run lint
+npm run format
+```
+
+### Documentation Style
+
+- Use Markdown for documentation
+- Follow the [Google Developer Documentation Style Guide](https://developers.google.com/style)
+- Include code examples where appropriate
+- Keep documentation up-to-date with code changes
+
+## Testing
+
+### Running Tests
+
+To run the test suite:
+
+```bash
+# Run all tests
+pytest
+
+# Run specific test files
+pytest tests/backend/
+pytest tests/eeg/
+pytest tests/integration/
+
+# Run with coverage report
+pytest --cov=.
+```
+
+For frontend tests:
+
+```bash
+cd frontend
+npm test
+```
+
+### Writing Tests
+
+- Write unit tests for all new features and bug fixes
+- Aim for at least 80% code coverage
+- Use pytest fixtures for test setup
+- Mock external dependencies
+- Write integration tests for critical paths
+
+Example test structure:
+
+```python
+def test_compute_focus_index():
+    # Arrange
+    theta = [1.0, 2.0, 3.0]
+    alpha = [2.0, 3.0, 4.0]
+    beta = [6.0, 9.0, 12.0]
+    
+    # Act
+    result = compute_focus_index(theta, alpha, beta)
+    
+    # Assert
+    expected = [2.0, 1.8, 1.714]
+    assert len(result) == len(expected)
+    for r, e in zip(result, expected):
+        assert round(r, 3) == e
+```
+
+## Issue Reporting
+
+If you find a bug or have a suggestion for improvement:
+
+1. Check if the issue already exists in the [GitHub Issues](https://github.com/yourusername/hackathon-mercor-etched-cognition/issues)
+2. If not, create a new issue using the appropriate template
+3. Include as much detail as possible:
+   - Steps to reproduce the issue
+   - Expected behavior
+   - Actual behavior
+   - Screenshots or logs if applicable
+   - Environment information (OS, Python version, browser, etc.)
+
+## Feature Requests
+
+We welcome feature requests! To submit a feature request:
+
+1. Check if the feature has already been requested in the [GitHub Issues](https://github.com/yourusername/hackathon-mercor-etched-cognition/issues)
+2. If not, create a new issue using the feature request template
+3. Clearly describe the feature and its benefits
+4. If possible, outline how the feature might be implemented
+
+## Documentation
+
+Good documentation is crucial for the project's success. When contributing:
+
+- Update the README.md if you change project setup or usage
+- Update or add docstrings for all public functions, classes, and methods
+- Update the API documentation if you change or add endpoints
+- Add examples for new features
+- Update installation and usage guides as needed
+
+## Community
+
+- Join our [Discord server](https://discord.gg/your-discord-invite) for discussions
+- Follow us on [Twitter](https://twitter.com/your-twitter-handle) for updates
+- Attend our monthly community calls (details in the Discord server)
+
+Thank you for contributing to the EEG-Enhanced Language Model with Mixture-of-Experts project!
diff --git a/docs/installation.md b/docs/installation.md
new file mode 100644
index 0000000..a765245
--- /dev/null
+++ b/docs/installation.md
@@ -0,0 +1,256 @@
+# Installation Guide
+
+This guide provides detailed instructions for setting up the EEG-Enhanced Language Model with Mixture-of-Experts project on different operating systems.
+
+## Table of Contents
+
+- [Prerequisites](#prerequisites)
+- [Installation](#installation)
+  - [Linux](#linux)
+  - [macOS](#macos)
+  - [Windows](#windows)
+- [Setting Up EEG Hardware](#setting-up-eeg-hardware)
+- [Troubleshooting](#troubleshooting)
+
+## Prerequisites
+
+Before installing the project, ensure you have the following prerequisites:
+
+### Software Requirements
+
+- **Python**: Version 3.8 or higher
+- **Node.js**: Version 14.0 or higher
+- **npm**: Version 6.0 or higher
+- **Git**: For cloning the repository
+
+### Hardware Requirements
+
+- **EEG Device** (optional): The project works with Muse EEG headsets, but can also run with simulated EEG data
+- **Computer**: Any modern computer with at least 4GB of RAM and 2GB of free disk space
+
+### Python Packages
+
+The project requires several Python packages, which will be installed automatically during the setup process:
+
+- FastAPI
+- Uvicorn
+- PyTorch
+- Transformers
+- NumPy
+- Matplotlib
+- SciPy
+- PyLSL (for EEG data streaming)
+
+## Installation
+
+### Linux
+
+1. **Clone the repository**:
+   ```bash
+   git clone https://github.com/yourusername/hackathon-mercor-etched-cognition.git
+   cd hackathon-mercor-etched-cognition
+   ```
+
+2. **Set up a Python virtual environment** (recommended):
+   ```bash
+   python -m venv venv
+   source venv/bin/activate
+   ```
+
+3. **Install Python dependencies**:
+   ```bash
+   pip install -r requirements.txt
+   ```
+
+4. **Install frontend dependencies**:
+   ```bash
+   cd frontend
+   npm install
+   cd ..
+   ```
+
+5. **Install the package in development mode** (optional):
+   ```bash
+   pip install -e .
+   ```
+
+### macOS
+
+1. **Clone the repository**:
+   ```bash
+   git clone https://github.com/yourusername/hackathon-mercor-etched-cognition.git
+   cd hackathon-mercor-etched-cognition
+   ```
+
+2. **Set up a Python virtual environment** (recommended):
+   ```bash
+   python -m venv venv
+   source venv/bin/activate
+   ```
+
+3. **Install Python dependencies**:
+   ```bash
+   pip install -r requirements.txt
+   ```
+
+4. **Install frontend dependencies**:
+   ```bash
+   cd frontend
+   npm install
+   cd ..
+   ```
+
+5. **Install the package in development mode** (optional):
+   ```bash
+   pip install -e .
+   ```
+
+### Windows
+
+1. **Clone the repository**:
+   ```bash
+   git clone https://github.com/yourusername/hackathon-mercor-etched-cognition.git
+   cd hackathon-mercor-etched-cognition
+   ```
+
+2. **Set up a Python virtual environment** (recommended):
+   ```bash
+   python -m venv venv
+   venv\Scripts\activate
+   ```
+
+3. **Install Python dependencies**:
+   ```bash
+   pip install -r requirements.txt
+   ```
+
+4. **Install frontend dependencies**:
+   ```bash
+   cd frontend
+   npm install
+   cd ..
+   ```
+
+5. **Install the package in development mode** (optional):
+   ```bash
+   pip install -e .
+   ```
+
+## Setting Up EEG Hardware
+
+### Muse Headset Setup
+
+If you have a Muse EEG headset, follow these steps to set it up:
+
+1. **Install the Muse SDK**:
+   ```bash
+   pip install muselsl
+   ```
+
+2. **Connect your Muse headset**:
+   - Turn on your Muse headset
+   - Pair it with your computer via Bluetooth
+   - Run the following command to list available Muse devices:
+     ```bash
+     muselsl list
+     ```
+
+3. **Stream EEG data**:
+   ```bash
+   muselsl stream --name YOUR_DEVICE_NAME
+   ```
+
+4. **Verify the connection**:
+   - Run the EEG visualization script to verify that data is being received:
+     ```bash
+     cd eeg
+     python eeg.py
+     ```
+
+### Using Simulated EEG Data
+
+If you don't have an EEG headset, you can use simulated data:
+
+1. **Enable test data generation**:
+   - Start the backend server (see [Usage Guide](usage.md))
+   - Send a POST request to enable test data:
+     ```bash
+     curl -X POST -H "Content-Type: application/json" -d '{"enable": true}' http://localhost:8000/toggle-test-data
+     ```
+
+## Troubleshooting
+
+### Common Issues
+
+#### Python Dependencies Installation Fails
+
+**Problem**: Error when installing Python dependencies.
+
+**Solution**:
+- Ensure you have the latest pip version:
+  ```bash
+  pip install --upgrade pip
+  ```
+- Try installing dependencies one by one to identify the problematic package
+- For PyTorch installation issues, visit the [official PyTorch website](https://pytorch.org/get-started/locally/) for specific installation instructions for your system
+
+#### EEG Device Not Detected
+
+**Problem**: The system cannot detect your EEG device.
+
+**Solution**:
+- Ensure your device is charged and turned on
+- Check Bluetooth connectivity
+- Restart your device and computer
+- Try reinstalling the Muse SDK:
+  ```bash
+  pip uninstall muselsl
+  pip install muselsl
+  ```
+
+#### Frontend Build Fails
+
+**Problem**: Error when building or running the frontend.
+
+**Solution**:
+- Ensure you have the correct Node.js version:
+  ```bash
+  node --version
+  ```
+- Clear npm cache:
+  ```bash
+  npm cache clean --force
+  ```
+- Delete node_modules and reinstall:
+  ```bash
+  cd frontend
+  rm -rf node_modules
+  npm install
+  ```
+
+#### Backend Server Won't Start
+
+**Problem**: Error when starting the FastAPI backend server.
+
+**Solution**:
+- Check if the port is already in use:
+  ```bash
+  # Linux/macOS
+  lsof -i :8000
+  
+  # Windows
+  netstat -ano | findstr :8000
+  ```
+- Kill the process using the port if necessary
+- Ensure all dependencies are installed correctly
+
+### Getting Help
+
+If you encounter issues not covered in this troubleshooting guide, please:
+
+1. Check the [GitHub Issues](https://github.com/yourusername/hackathon-mercor-etched-cognition/issues) to see if someone has reported a similar problem
+2. Create a new issue with detailed information about your problem, including:
+   - Operating system and version
+   - Python and Node.js versions
+   - Error messages
+   - Steps to reproduce the issue
diff --git a/docs/technical_approach.md b/docs/technical_approach.md
new file mode 100644
index 0000000..3f42673
--- /dev/null
+++ b/docs/technical_approach.md
@@ -0,0 +1,380 @@
+# Technical Approach
+
+This document provides a comprehensive explanation of the technical approaches used in the EEG-Enhanced Language Model with Mixture-of-Experts project. It covers the architecture, components, algorithms, and implementation details of the system.
+
+## Table of Contents
+
+- [System Overview](#system-overview)
+- [EEG Signal Processing](#eeg-signal-processing)
+  - [Frequency Band Analysis](#frequency-band-analysis)
+  - [Attention Metrics](#attention-metrics)
+- [Mixture-of-Experts Architecture](#mixture-of-experts-architecture)
+  - [Expert Configurations](#expert-configurations)
+  - [Dynamic Routing](#dynamic-routing)
+- [Language Model Integration](#language-model-integration)
+  - [Token Generation Process](#token-generation-process)
+  - [Parameter Adaptation](#parameter-adaptation)
+- [Token Streaming](#token-streaming)
+- [Frontend Visualization](#frontend-visualization)
+- [Performance Considerations](#performance-considerations)
+- [Future Directions](#future-directions)
+
+## System Overview
+
+The EEG-Enhanced Language Model with Mixture-of-Experts (EEG-LM-MoE) is a brain-computer interface that enhances language model generation based on real-time EEG signals. The system dynamically adapts the language model's output based on detected attention levels, providing a more personalized and responsive text generation experience.
+
+### Architecture Diagram
+
+```
+‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
+‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
+‚îÇ   EEG Device    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  EEG Processor  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  MoE Controller ‚îÇ
+‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
+‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
+                                                         ‚îÇ
+                                                         ‚ñº
+‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
+‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
+‚îÇ    Frontend     ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Token Streaming ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ Language Model  ‚îÇ
+‚îÇ  Visualization  ‚îÇ     ‚îÇ     Backend     ‚îÇ     ‚îÇ                 ‚îÇ
+‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ     ‚îÇ                 ‚îÇ
+‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
+```
+
+### Key Components
+
+1. **EEG Device**: Captures brain signals (real or simulated)
+2. **EEG Processor**: Analyzes EEG signals to extract attention metrics
+3. **MoE Controller**: Routes generation through different experts based on attention levels
+4. **Language Model**: Generates text with parameters adapted by the MoE controller
+5. **Token Streaming Backend**: Handles streaming of tokens to the frontend
+6. **Frontend Visualization**: Displays the generated text with expert-specific styling
+
+### Data Flow
+
+1. EEG signals are captured from the user's brain or simulated
+2. The EEG processor analyzes the signals to extract attention metrics
+3. The MoE controller uses attention metrics to determine expert weights
+4. The language model generates tokens with parameters adapted by the MoE controller
+5. Generated tokens are streamed to the frontend via the backend
+6. The frontend visualizes the tokens with different colors based on the expert
+
+## EEG Signal Processing
+
+### Frequency Band Analysis
+
+EEG signals are analyzed in the frequency domain to extract power in different frequency bands:
+
+- **Theta (4-7 Hz)**: Associated with drowsiness, inattention
+- **Alpha (8-13 Hz)**: Associated with relaxation, meditation
+- **Beta (14-30 Hz)**: Associated with active thinking, focus
+- **Gamma (31-50 Hz)**: Associated with cognitive processing, attention
+
+The power in each frequency band is computed using Welch's method for power spectral density estimation:
+
+```python
+def compute_band_power(data, fs, band):
+    """Compute the power in a specific frequency band of an EEG signal."""
+    freqs, psd = welch(data, fs, nperseg=fs)
+    return np.trapz(psd[(freqs >= band[0]) & (freqs <= band[1])])
+```
+
+### Attention Metrics
+
+Attention metrics are derived from the relative power in different frequency bands:
+
+1. **Focus Index**: Ratio of beta power to the sum of alpha and theta power
+   ```python
+   focus_index = beta_power / (alpha_power + theta_power)
+   ```
+
+2. **Attention Level**: Categorized as low, medium, or high based on thresholds
+   ```python
+   if focus_index < LOW_THRESHOLD:
+       attention_level = "low"
+   elif focus_index < HIGH_THRESHOLD:
+       attention_level = "medium"
+   else:
+       attention_level = "high"
+   ```
+
+### Signal Processing Pipeline
+
+1. **Data Collection**: EEG data is collected in chunks from the LSL stream
+2. **Windowing**: The data is divided into overlapping windows (e.g., 2-second windows with 1-second overlap)
+3. **Frequency Analysis**: Each window is analyzed to compute power in different frequency bands
+4. **Attention Metrics**: Attention metrics are computed from the frequency band powers
+5. **Smoothing**: Metrics are smoothed over time to reduce noise and prevent rapid fluctuations
+
+## Mixture-of-Experts Architecture
+
+The Mixture-of-Experts (MoE) architecture dynamically routes token generation through different "expert" configurations based on the user's attention level.
+
+### Expert Configurations
+
+The system implements three expert configurations:
+
+1. **Simplicity Expert (Low Attention)**
+   - **Purpose**: Generate simpler, more accessible text when attention is low
+   - **Parameters**:
+     - Higher temperature (e.g., 0.9-1.2) for more varied, simpler outputs
+     - Lower top-k (e.g., 20-50) to focus on common tokens
+     - Higher repetition penalty (e.g., 1.2-1.5) to avoid complex structures
+     - Token biasing toward common words and simplifying phrases
+
+2. **Balanced Expert (Medium Attention)**
+   - **Purpose**: Generate balanced text with moderate complexity
+   - **Parameters**:
+     - Moderate temperature (e.g., 0.7-0.9)
+     - Moderate top-k (e.g., 50-100)
+     - Standard repetition penalty (e.g., 1.1-1.2)
+     - Balanced token distribution without strong biasing
+
+3. **Complexity Expert (High Attention)**
+   - **Purpose**: Generate more complex, information-dense text when attention is high
+   - **Parameters**:
+     - Lower temperature (e.g., 0.5-0.7) for more deterministic, focused outputs
+     - Higher top-k (e.g., 100-200) allowing for more specialized tokens
+     - Lower repetition penalty (e.g., 1.0-1.1) to allow complex structures
+     - Token biasing toward rare/technical tokens and complex phrases
+
+### Dynamic Routing
+
+The MoE controller dynamically routes token generation through the experts based on the current attention level:
+
+1. **Expert Weighting**: Weights are assigned to each expert based on the attention level
+   ```python
+   # Example weighting function
+   def compute_expert_weights(attention_level):
+       if attention_level == "low":
+           return {"simple": 0.7, "balanced": 0.2, "complex": 0.1}
+       elif attention_level == "medium":
+           return {"simple": 0.2, "balanced": 0.6, "complex": 0.2}
+       else:  # high
+           return {"simple": 0.1, "balanced": 0.2, "complex": 0.7}
+   ```
+
+2. **Parameter Interpolation**: Generation parameters are interpolated based on expert weights
+   ```python
+   # Example parameter interpolation
+   temperature = (
+       simple_weight * simple_temperature +
+       balanced_weight * balanced_temperature +
+       complex_weight * complex_temperature
+   )
+   ```
+
+3. **Token Biasing**: Token probabilities are adjusted based on expert weights
+   ```python
+   # Example token biasing
+   for token_id, bias in token_biases.items():
+       logits[token_id] += (
+           simple_weight * simple_bias[token_id] +
+           balanced_weight * balanced_bias[token_id] +
+           complex_weight * complex_bias[token_id]
+       )
+   ```
+
+## Language Model Integration
+
+### Token Generation Process
+
+The language model generates tokens one by one, with each token's generation parameters adapted based on the current attention level:
+
+1. **Input Processing**: The input prompt is tokenized and encoded
+2. **Attention Sampling**: The current attention level is sampled from the EEG processor
+3. **Expert Weighting**: Expert weights are computed based on the attention level
+4. **Parameter Adaptation**: Generation parameters are adapted based on expert weights
+5. **Token Generation**: A token is generated using the adapted parameters
+6. **Expert Assignment**: The token is assigned to the expert with the highest weight
+7. **Token Streaming**: The token and its expert are sent to the token streaming backend
+8. **Repeat**: Steps 2-7 are repeated for each token until generation is complete
+
+### Parameter Adaptation
+
+The language model's parameters are adapted in real-time based on the attention level:
+
+1. **Temperature**: Controls the randomness of token selection
+   - Higher temperature for low attention (more varied, simpler outputs)
+   - Lower temperature for high attention (more deterministic, focused outputs)
+
+2. **Top-k Sampling**: Limits token selection to the top k most likely tokens
+   - Lower top-k for low attention (focus on common tokens)
+   - Higher top-k for high attention (allow for more specialized tokens)
+
+3. **Repetition Penalty**: Penalizes repetition of tokens
+   - Higher penalty for low attention (avoid complex structures)
+   - Lower penalty for high attention (allow complex structures)
+
+4. **Token Biasing**: Adjusts token probabilities
+   - Bias toward common words for low attention
+   - Bias toward rare/technical words for high attention
+
+## Token Streaming
+
+The token streaming backend handles the streaming of tokens from the language model to the frontend:
+
+1. **Token Queue**: Tokens are added to a queue with their associated experts
+   ```python
+   token_queue.append({
+       "word": token,
+       "number": EXPERT_COLORS[expert]
+   })
+   ```
+
+2. **Server-Sent Events**: Tokens are streamed to the frontend using server-sent events
+   ```python
+   async def event_stream():
+       while True:
+           if token_queue:
+               data = token_queue.popleft()
+               yield f"data: {json.dumps(data)}\n\n"
+               await asyncio.sleep(0.1 + random.random() * 0.1)
+           else:
+               await asyncio.sleep(0.2)
+   ```
+
+3. **Color Mapping**: Each expert is mapped to a color for visualization
+   ```python
+   EXPERT_COLORS = {
+       "simple": 1,     # Maps to color 1 in frontend (e.g., blue)
+       "balanced": 2,   # Maps to color 2 in frontend (e.g., green)
+       "complex": 3,    # Maps to color 3 in frontend (e.g., red)
+       "unknown": 2     # Default to balanced/middle color if expert is unknown
+   }
+   ```
+
+## Frontend Visualization
+
+The frontend visualizes the streamed tokens with different colors based on the expert:
+
+1. **EventSource**: Establishes a connection to the token streaming endpoint
+   ```javascript
+   const eventSource = new EventSource('/stream');
+   eventSource.onmessage = (event) => {
+       const data = JSON.parse(event.data);
+       displayToken(data.word, data.number);
+   };
+   ```
+
+2. **Token Display**: Displays tokens with different colors based on the expert
+   ```javascript
+   function displayToken(word, expertColor) {
+       const tokenElement = document.createElement('span');
+       tokenElement.textContent = word;
+       tokenElement.className = `expert-${expertColor}`;
+       outputContainer.appendChild(tokenElement);
+   }
+   ```
+
+3. **Visualization Components**: Additional components visualize attention levels and expert weights
+   - Attention level gauge
+   - Expert weight distribution chart
+   - Token generation statistics
+
+## Performance Considerations
+
+### Real-time Processing
+
+The system is designed for real-time processing with minimal latency:
+
+1. **EEG Processing**: Optimized for low-latency processing of EEG signals
+   - Efficient frequency analysis using Welch's method
+   - Overlapping windows to reduce latency
+   - Parallel processing of channels
+
+2. **Token Generation**: Optimized for responsive token generation
+   - Batched processing of input
+   - Efficient parameter adaptation
+   - Asynchronous token streaming
+
+3. **Frontend Rendering**: Optimized for smooth visualization
+   - Efficient DOM updates
+   - Throttled rendering of visualization components
+   - WebGL-based visualization for complex charts
+
+### Resource Usage
+
+The system is designed to be resource-efficient:
+
+1. **Memory Usage**: Optimized for low memory usage
+   - Limited token queue size
+   - Efficient data structures
+   - Garbage collection of processed data
+
+2. **CPU Usage**: Optimized for low CPU usage
+   - Efficient algorithms for EEG processing
+   - Throttled token generation
+   - Debounced event handlers
+
+3. **Network Usage**: Optimized for low network usage
+   - Compact token representation
+   - Efficient server-sent events
+   - Batched updates when possible
+
+## Future Directions
+
+### Enhanced EEG Processing
+
+1. **Advanced Signal Processing**: Implement more advanced signal processing techniques
+   - Independent Component Analysis (ICA) for artifact removal
+   - Wavelet analysis for time-frequency representation
+   - Deep learning-based feature extraction
+
+2. **Personalized Attention Metrics**: Develop personalized attention metrics
+   - Calibration phase to establish baseline
+   - Adaptive thresholds based on user history
+   - Multi-modal attention metrics (EEG, eye tracking, etc.)
+
+### Improved MoE Architecture
+
+1. **More Experts**: Implement more specialized experts
+   - Domain-specific experts (technical, creative, etc.)
+   - Style-specific experts (formal, casual, etc.)
+   - Emotion-specific experts (happy, sad, etc.)
+
+2. **Hierarchical MoE**: Implement a hierarchical MoE architecture
+   - Top-level experts for high-level decisions
+   - Sub-experts for specialized tasks
+   - Dynamic expert creation and pruning
+
+### Enhanced Language Model Integration
+
+1. **Fine-tuning**: Fine-tune language models for better adaptation
+   - Attention-aware fine-tuning
+   - Expert-specific fine-tuning
+   - Continual learning from user feedback
+
+2. **Multi-modal Integration**: Integrate with other modalities
+   - Vision-language models
+   - Audio-language models
+   - Multimodal attention metrics
+
+### Improved Visualization
+
+1. **3D Visualization**: Implement 3D visualization of brain activity
+   - Source localization
+   - Functional connectivity
+   - Dynamic network analysis
+
+2. **Augmented Reality**: Implement AR visualization
+   - Overlay brain activity on real-world view
+   - Spatial token visualization
+   - Interactive AR interface
+
+### Practical Applications
+
+1. **Educational Tools**: Develop educational tools
+   - Adaptive learning systems
+   - Attention-aware tutoring
+   - Cognitive load monitoring
+
+2. **Accessibility Tools**: Develop accessibility tools
+   - Attention-aware assistive technology
+   - Cognitive state-based interface adaptation
+   - Personalized communication aids
+
+3. **Creative Tools**: Develop creative tools
+   - Attention-aware writing assistants
+   - Brain-computer interfaces for art and music
+   - Collaborative creativity platforms
diff --git a/docs/usage.md b/docs/usage.md
new file mode 100644
index 0000000..ee6087b
--- /dev/null
+++ b/docs/usage.md
@@ -0,0 +1,299 @@
+# Usage Guide
+
+This guide provides detailed instructions for using the EEG-Enhanced Language Model with Mixture-of-Experts project. It covers how to start the backend and frontend components, run the EEG processing script, and use the Kevin-MOE demo.
+
+## Table of Contents
+
+- [Starting the Backend Server](#starting-the-backend-server)
+- [Starting the Frontend Application](#starting-the-frontend-application)
+- [Running the EEG Processing Script](#running-the-eeg-processing-script)
+- [Using the Kevin-MOE Demo](#using-the-kevin-moe-demo)
+- [Advanced Usage](#advanced-usage)
+- [API Endpoints](#api-endpoints)
+
+## Starting the Backend Server
+
+The backend server is built with FastAPI and handles token streaming and expert routing.
+
+1. **Navigate to the backend directory**:
+   ```bash
+   cd hackathon-mercor-etched-cognition/backend
+   ```
+
+2. **Start the server**:
+   ```bash
+   uvicorn main:app --reload
+   ```
+
+   This will start the server on `http://localhost:8000`. The `--reload` flag enables auto-reloading when code changes are detected, which is useful during development.
+
+3. **Verify the server is running**:
+   - Open a web browser and navigate to `http://localhost:8000/docs`
+   - You should see the FastAPI Swagger UI with all available endpoints
+
+## Starting the Frontend Application
+
+The frontend application is built with React and provides a visualization interface for the EEG-enhanced language model.
+
+1. **Navigate to the frontend directory**:
+   ```bash
+   cd hackathon-mercor-etched-cognition/frontend
+   ```
+
+2. **Install dependencies** (if not already done):
+   ```bash
+   npm install
+   ```
+
+3. **Start the development server**:
+   ```bash
+   npm start
+   ```
+
+   This will start the frontend application on `http://localhost:3000`.
+
+4. **Interact with the application**:
+   - Open a web browser and navigate to `http://localhost:3000`
+   - You should see the visualization interface for the EEG-enhanced language model
+   - The interface will display tokens streamed from the backend with different colors based on the expert that generated them
+
+## Running the EEG Processing Script
+
+The EEG processing script processes EEG signals to extract attention metrics.
+
+### Using Real EEG Data
+
+1. **Connect your EEG device** (if using real EEG data):
+   - Turn on your Muse headset
+   - Pair it with your computer via Bluetooth
+   - Start streaming EEG data using muselsl:
+     ```bash
+     muselsl stream --name YOUR_DEVICE_NAME
+     ```
+
+2. **Navigate to the EEG directory**:
+   ```bash
+   cd hackathon-mercor-etched-cognition/eeg
+   ```
+
+3. **Run the EEG processing script**:
+   ```bash
+   python eeg.py
+   ```
+
+   This will start processing EEG data and visualizing attention levels in real-time.
+
+### Using Simulated EEG Data
+
+If you don't have an EEG device, you can use simulated data:
+
+1. **Navigate to the EEG directory**:
+   ```bash
+   cd hackathon-mercor-etched-cognition/eeg
+   ```
+
+2. **Run the EEG processing script with the simulation flag**:
+   ```bash
+   python eeg.py --simulate
+   ```
+
+   This will generate simulated EEG data and process it as if it were coming from a real device.
+
+## Using the Kevin-MOE Demo
+
+The Kevin-MOE demo implements the EEG-Enhanced Language Model with Mixture-of-Experts.
+
+1. **Navigate to the Kevin-MOE demo directory**:
+   ```bash
+   cd hackathon-mercor-etched-cognition/kevin-moe-demo
+   ```
+
+2. **Install dependencies** (if not already done):
+   ```bash
+   pip install -r requirements.txt
+   ```
+
+3. **Run the demo script**:
+   ```bash
+   python demo.py
+   ```
+
+   This will start the demo with simulated EEG data.
+
+4. **Run the demo with real EEG data** (if available):
+   ```bash
+   python demo.py --real-eeg
+   ```
+
+   This will use real EEG data from your connected device.
+
+5. **Interact with the demo**:
+   - Type prompts when prompted
+   - Observe how the language model adapts its responses based on your attention levels
+   - The demo will display which expert is being used for each token
+
+## Advanced Usage
+
+### Running the Full System
+
+To run the full system with all components:
+
+1. **Start the backend server** (in one terminal):
+   ```bash
+   cd hackathon-mercor-etched-cognition/backend
+   uvicorn main:app --reload
+   ```
+
+2. **Start the EEG processing script** (in another terminal):
+   ```bash
+   cd hackathon-mercor-etched-cognition/eeg
+   python eeg.py
+   ```
+
+3. **Start the frontend application** (in a third terminal):
+   ```bash
+   cd hackathon-mercor-etched-cognition/frontend
+   npm start
+   ```
+
+4. **Start the Kevin-MOE demo** (in a fourth terminal):
+   ```bash
+   cd hackathon-mercor-etched-cognition/kevin-moe-demo
+   python demo.py
+   ```
+
+### Customizing the System
+
+#### Adjusting EEG Processing Parameters
+
+You can adjust the EEG processing parameters in `eeg/eeg.py`:
+
+- `FS`: EEG sampling rate (default: 256 Hz)
+- `WINDOW_SIZE`: Window size for frequency analysis (default: 2 seconds)
+- `STEP_SIZE`: Step size for sliding window (default: 1 second)
+- `BANDS`: Frequency bands for analysis (theta, alpha, beta, gamma, sixty)
+- `THRESHOLD_GAMMA`: Threshold for gamma band power to determine focus level
+
+#### Customizing the Mixture-of-Experts Controller
+
+You can customize the Mixture-of-Experts controller in `kevin-moe-demo/moe_control.py`:
+
+- Adjust the expert configurations for different attention levels
+- Modify the token biasing strategies
+- Change the temperature and top-k sampling parameters
+
+## API Endpoints
+
+The backend server provides several API endpoints:
+
+### `/add-tokens` (POST)
+
+Add tokens to the streaming queue.
+
+**Request Body**:
+```json
+{
+  "tokens": [
+    {
+      "token": "Hello",
+      "expert": "simple"
+    },
+    {
+      "token": " ",
+      "expert": "balanced"
+    },
+    {
+      "token": "world",
+      "expert": "complex"
+    }
+  ]
+}
+```
+
+**Response**:
+```json
+{
+  "status": "success",
+  "tokens_added": 3
+}
+```
+
+### `/stream` (GET)
+
+Stream tokens to the frontend using server-sent events.
+
+**Response**: Server-sent events with token data.
+
+### `/clear-tokens` (POST)
+
+Clear all tokens from the token queue.
+
+**Response**:
+```json
+{
+  "status": "success",
+  "message": "Token queue cleared"
+}
+```
+
+### `/toggle-test-data` (POST)
+
+Enable or disable random test data generation.
+
+**Request Body**:
+```json
+{
+  "enable": true
+}
+```
+
+**Response**:
+```json
+{
+  "status": "success",
+  "test_data_enabled": true
+}
+```
+
+### `/status` (GET)
+
+Get the current status of the server.
+
+**Response**:
+```json
+{
+  "queue_size": 10,
+  "test_data_enabled": false
+}
+```
+
+### `/debug-tokens` (GET)
+
+Get a dump of recently processed tokens for debugging.
+
+**Query Parameters**:
+- `limit`: Maximum number of tokens to return (default: 50)
+
+**Response**:
+```json
+{
+  "queue_size": 15,
+  "tokens": [
+    {
+      "word": "Hello",
+      "number": 1
+    },
+    {
+      "word": " ",
+      "number": 2
+    },
+    {
+      "word": "world",
+      "number": 3
+    }
+  ],
+  "test_data_enabled": false
+}
+```
+
+For more detailed API documentation, see the [API Documentation](api.md).
diff --git a/eeg/eeg.ipynb b/eeg/eeg.ipynb
new file mode 100644
index 0000000..dfc867f
--- /dev/null
+++ b/eeg/eeg.ipynb
@@ -0,0 +1,223 @@
+{
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 5,
+   "id": "91dbbb46-5080-46a1-a12c-dbca18cc947e",
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "image/png": "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",
+      "text/plain": [
+       "<Figure size 1000x400 with 2 Axes>"
+      ]
+     },
+     "metadata": {},
+     "output_type": "display_data"
+    },
+    {
+     "ename": "KeyboardInterrupt",
+     "evalue": "",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
+      "Cell \u001b[0;32mIn[5], line 83\u001b[0m\n\u001b[1;32m     80\u001b[0m current_time \u001b[38;5;241m=\u001b[39m time\u001b[38;5;241m.\u001b[39mtime() \u001b[38;5;241m-\u001b[39m start_time\n\u001b[1;32m     82\u001b[0m \u001b[38;5;66;03m# Collect and process data\u001b[39;00m\n\u001b[0;32m---> 83\u001b[0m new_data, new_timestamps \u001b[38;5;241m=\u001b[39m \u001b[43mcollect_data\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m2\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m     84\u001b[0m band_levels \u001b[38;5;241m=\u001b[39m process_data(new_data)\n\u001b[1;32m     85\u001b[0m focus_level \u001b[38;5;241m=\u001b[39m np\u001b[38;5;241m.\u001b[39mmean(band_levels[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mgamma\u001b[39m\u001b[38;5;124m\"\u001b[39m])\n",
+      "Cell \u001b[0;32mIn[5], line 46\u001b[0m, in \u001b[0;36mcollect_data\u001b[0;34m(recording_time)\u001b[0m\n\u001b[1;32m     44\u001b[0m all_data, all_timestamps \u001b[38;5;241m=\u001b[39m [], []\n\u001b[1;32m     45\u001b[0m \u001b[38;5;28;01mwhile\u001b[39;00m time\u001b[38;5;241m.\u001b[39mtime() \u001b[38;5;241m-\u001b[39m start_time \u001b[38;5;241m<\u001b[39m recording_time:\n\u001b[0;32m---> 46\u001b[0m     data, timestamps \u001b[38;5;241m=\u001b[39m \u001b[43minlet\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mpull_chunk\u001b[49m\u001b[43m(\u001b[49m\u001b[43mtimeout\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;241;43m0.1\u001b[39;49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mmax_samples\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mCHUNK_LENGTH\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m     47\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m timestamps:\n\u001b[1;32m     48\u001b[0m         all_data\u001b[38;5;241m.\u001b[39mextend(data)\n",
+      "File \u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.13/lib/python3.13/site-packages/pylsl/inlet.py:255\u001b[0m, in \u001b[0;36mStreamInlet.pull_chunk\u001b[0;34m(self, timeout, max_samples, dest_obj)\u001b[0m\n\u001b[1;32m    253\u001b[0m errcode \u001b[38;5;241m=\u001b[39m ctypes\u001b[38;5;241m.\u001b[39mc_int()\n\u001b[1;32m    254\u001b[0m \u001b[38;5;66;03m# noinspection PyCallingNonCallable\u001b[39;00m\n\u001b[0;32m--> 255\u001b[0m num_elements \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mdo_pull_chunk\u001b[49m\u001b[43m(\u001b[49m\n\u001b[1;32m    256\u001b[0m \u001b[43m    \u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mobj\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    257\u001b[0m \u001b[43m    \u001b[49m\u001b[43mctypes\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mbyref\u001b[49m\u001b[43m(\u001b[49m\u001b[43mdata_buff\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    258\u001b[0m \u001b[43m    \u001b[49m\u001b[43mctypes\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mbyref\u001b[49m\u001b[43m(\u001b[49m\u001b[43mts_buff\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    259\u001b[0m \u001b[43m    \u001b[49m\u001b[43mctypes\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mc_size_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43mmax_values\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    260\u001b[0m \u001b[43m    \u001b[49m\u001b[43mctypes\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mc_size_t\u001b[49m\u001b[43m(\u001b[49m\u001b[43mmax_samples\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    261\u001b[0m \u001b[43m    \u001b[49m\u001b[43mctypes\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mc_double\u001b[49m\u001b[43m(\u001b[49m\u001b[43mtimeout\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    262\u001b[0m \u001b[43m    \u001b[49m\u001b[43mctypes\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mbyref\u001b[49m\u001b[43m(\u001b[49m\u001b[43merrcode\u001b[49m\u001b[43m)\u001b[49m\u001b[43m,\u001b[49m\n\u001b[1;32m    263\u001b[0m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    264\u001b[0m handle_error(errcode)\n\u001b[1;32m    265\u001b[0m \u001b[38;5;66;03m# return results (note: could offer a more efficient format in the\u001b[39;00m\n\u001b[1;32m    266\u001b[0m \u001b[38;5;66;03m# future, e.g., a numpy array)\u001b[39;00m\n",
+      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
+     ]
+    }
+   ],
+   "source": [
+    "import numpy as np\n",
+    "import matplotlib.pyplot as plt\n",
+    "from pylsl import StreamInlet, resolve_byprop\n",
+    "import time\n",
+    "from scipy.signal import welch\n",
+    "from IPython.display import clear_output\n",
+    "\n",
+    "# Parameters\n",
+    "FS = 256  # EEG sampling rate (update based on device)\n",
+    "CHUNK_LENGTH = 12\n",
+    "LSL_SCAN_TIMEOUT = 5\n",
+    "WINDOW_SIZE = FS * 2  # 2-second window\n",
+    "STEP_SIZE = FS  # 1-second step\n",
+    "\n",
+    "# Frequency Bands\n",
+    "BANDS = {\n",
+    "    \"theta\": (4, 7),\n",
+    "    \"alpha\": (8, 13),\n",
+    "    \"beta\": (14, 30),\n",
+    "    \"gamma\": (31, 50),\n",
+    "    \"sixty\": (55, 65),\n",
+    "}\n",
+    "\n",
+    "# Function to compute band power\n",
+    "def compute_band_power(data, fs, band):\n",
+    "    freqs, psd = welch(data, fs, nperseg=fs)\n",
+    "    return np.trapz(psd[(freqs >= band[0]) & (freqs <= band[1])])\n",
+    "\n",
+    "# Resolve EEG stream\n",
+    "print(\"Looking for an EEG stream...\")\n",
+    "streams = resolve_byprop('type', 'EEG', timeout=LSL_SCAN_TIMEOUT)\n",
+    "if not streams:\n",
+    "    raise RuntimeError(\"EEG Stream not found.\")\n",
+    "\n",
+    "print(\"Started acquiring data.\")\n",
+    "inlet = StreamInlet(streams[0], max_chunklen=CHUNK_LENGTH)\n",
+    "info = inlet.info()\n",
+    "NCHAN = info.channel_count()\n",
+    "CH_NAMES = ['TP9', 'AF7', 'AF8', 'TP10', 'AUX'][:NCHAN]\n",
+    "\n",
+    "# Data collection function\n",
+    "def collect_data(recording_time=30):\n",
+    "    start_time = time.time()\n",
+    "    all_data, all_timestamps = [], []\n",
+    "    while time.time() - start_time < recording_time:\n",
+    "        data, timestamps = inlet.pull_chunk(timeout=0.1, max_samples=CHUNK_LENGTH)\n",
+    "        if timestamps:\n",
+    "            all_data.extend(data)\n",
+    "            all_timestamps.extend(timestamps)\n",
+    "    return np.array(all_data).T, np.array(all_timestamps)\n",
+    "\n",
+    "# Process EEG data\n",
+    "def process_data(all_data):\n",
+    "    band_levels = {key: [] for key in BANDS}\n",
+    "    for start in range(0, all_data.shape[1] - WINDOW_SIZE, STEP_SIZE):\n",
+    "        window_data = all_data[:, start:start + WINDOW_SIZE]\n",
+    "        for band_name, band_range in BANDS.items():\n",
+    "            band_levels[band_name].append(\n",
+    "                np.mean([compute_band_power(ch_data, FS, band_range) for ch_data in window_data])\n",
+    "            )\n",
+    "    return band_levels\n",
+    "\n",
+    "# Compute focus index\n",
+    "def compute_focus_index(theta, alpha, beta):\n",
+    "    epsilon = 1e-6  # Avoid division by zero\n",
+    "    return (np.array(beta) / (np.array(alpha) + np.array(theta) + epsilon)).tolist()\n",
+    "\n",
+    "# Thresholds (adjust as needed)\n",
+    "THRESHOLD_GAMMA = 8\n",
+    "THRESHOLD_SIXTY = 250\n",
+    "\n",
+    "# Live Plotting\n",
+    "timestamps, focus_levels, target_focus_levels = [], [], []\n",
+    "start_time = time.time()\n",
+    "focus_or_not = True\n",
+    "while True:\n",
+    "    focus_or_not = not focus_or_not\n",
+    "    for _ in range(15):\n",
+    "        target_focus = 14 if focus_or_not else 5\n",
+    "        current_time = time.time() - start_time\n",
+    "        \n",
+    "        # Collect and process data\n",
+    "        new_data, new_timestamps = collect_data(2)\n",
+    "        band_levels = process_data(new_data)\n",
+    "        focus_level = np.mean(band_levels[\"gamma\"])\n",
+    "        \n",
+    "        # Determine shared variable\n",
+    "        focus_val = 2 if focus_level > THRESHOLD_GAMMA * 2 else 1 if focus_level > THRESHOLD_GAMMA else 0\n",
+    "        print(focus_val)\n",
+    "        \n",
+    "        # Update plot data\n",
+    "        timestamps.append(current_time)\n",
+    "        focus_levels.append(focus_level)\n",
+    "        target_focus_levels.append(target_focus)\n",
+    "        \n",
+    "        # Clear and redraw plot\n",
+    "        clear_output(wait=True)\n",
+    "        fig, axes = plt.subplots(2, 1, figsize=(10, 4))\n",
+    "        \n",
+    "        # Focus Level Plot\n",
+    "        axes[0].plot(timestamps, focus_levels, label=\"Focus Level\")\n",
+    "        axes[0].plot(timestamps, target_focus_levels, label=\"Target Focus Level\", linestyle='dashed')\n",
+    "        axes[0].set_xlabel(\"Time (s)\")\n",
+    "        axes[0].set_ylabel(\"Focus Level\")\n",
+    "        axes[0].legend()\n",
+    "        axes[0].set_title(\"Focus Level Over Time\")\n",
+    "        \n",
+    "        # EEG Data Plot\n",
+    "        for i in range(NCHAN):\n",
+    "            axes[1].plot(new_timestamps - new_timestamps[0], new_data[i] + i * 100, label=CH_NAMES[i])\n",
+    "        \n",
+    "        axes[1].set_xlabel(\"Time (s)\")\n",
+    "        axes[1].set_ylabel(\"EEG Signal\")\n",
+    "        axes[1].set_title(\"EEG Data Over 10 Seconds\")\n",
+    "        axes[1].legend()\n",
+    "        \n",
+    "        plt.tight_layout()\n",
+    "        plt.show()\n"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "id": "e1dfa46e-203d-4b19-b46d-f88242f272cc",
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import nest_asyncio\n",
+    "import uvicorn\n",
+    "import threading\n",
+    "from fastapi import FastAPI\n",
+    "import asyncio\n",
+    "\n",
+    "# Apply nest_asyncio to allow running FastAPI inside Jupyter\n",
+    "nest_asyncio.apply()\n",
+    "\n",
+    "app = FastAPI()\n",
+    "\n",
+    "# Global variable to be updated\n",
+    "shared_var = 0\n",
+    "\n",
+    "# Async function to simulate real-time updates\n",
+    "async def update_var():\n",
+    "    global shared_var\n",
+    "    while True:\n",
+    "        await asyncio.sleep(1)  # Update every second\n",
+    "        #shared_var += 1\n",
+    "\n",
+    "# FastAPI endpoint to return the latest value\n",
+    "@app.get(\"/latest_value\")\n",
+    "async def get_latest_value():\n",
+    "    return {\"shared_var\": focus_val}\n",
+    "\n",
+    "# Start real-time updates in the background\n",
+    "@app.on_event(\"startup\")\n",
+    "async def startup():\n",
+    "    asyncio.create_task(update_var())\n",
+    "\n",
+    "# Function to run FastAPI in a separate thread\n",
+    "def run_server():\n",
+    "    uvicorn.run(app, host=\"127.0.0.1\", port=8000)\n",
+    "\n",
+    "# Run the server in a separate thread so it doesn't block Jupyter\n",
+    "server_thread = threading.Thread(target=run_server, daemon=True)\n",
+    "server_thread.start()\n"
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "Python 3 (ipykernel)",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.13.2"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 5
+}
diff --git a/eeg/eeg.py b/eeg/eeg.py
new file mode 100644
index 0000000..91016fe
--- /dev/null
+++ b/eeg/eeg.py
@@ -0,0 +1,325 @@
+#!/usr/bin/env python
+# coding: utf-8
+
+"""
+EEG Signal Processing Module
+
+This module provides functions for processing EEG signals, computing frequency band powers,
+and calculating focus/attention metrics. It can connect to EEG devices through Lab Streaming
+Layer (LSL) protocol and process real-time EEG data.
+
+The module includes functionality for:
+- Connecting to EEG devices via LSL
+- Collecting and processing EEG data
+- Computing frequency band powers (theta, alpha, beta, gamma)
+- Calculating focus/attention metrics
+- Visualizing EEG data and focus levels in real-time
+- Exposing focus metrics via a FastAPI endpoint
+"""
+
+import numpy as np
+import matplotlib.pyplot as plt
+from pylsl import StreamInlet, resolve_byprop
+import time
+from scipy.signal import welch
+from IPython.display import clear_output
+
+# Parameters
+FS = 256  # EEG sampling rate (update based on device)
+CHUNK_LENGTH = 12
+LSL_SCAN_TIMEOUT = 5
+WINDOW_SIZE = FS * 2  # 2-second window
+STEP_SIZE = FS  # 1-second step
+
+# Frequency Bands
+BANDS = {
+    "theta": (4, 7),
+    "alpha": (8, 13),
+    "beta": (14, 30),
+    "gamma": (31, 50),
+    "sixty": (55, 65),
+}
+
+def compute_band_power(data, fs, band):
+    """
+    Compute the power in a specific frequency band of an EEG signal.
+    
+    This function calculates the power spectral density (PSD) of the input signal
+    using Welch's method and then integrates the PSD over the specified frequency band.
+    
+    Args:
+        data (numpy.ndarray): The EEG signal time series
+        fs (int): Sampling frequency of the EEG signal in Hz
+        band (tuple): Frequency band as a tuple of (low_freq, high_freq) in Hz
+    
+    Returns:
+        float: The power in the specified frequency band
+    
+    Example:
+        ```python
+        # Compute alpha band power (8-13 Hz) for an EEG channel
+        alpha_power = compute_band_power(eeg_data[0], 256, (8, 13))
+        ```
+    """
+    freqs, psd = welch(data, fs, nperseg=fs)
+    band_mask = (freqs >= band[0]) & (freqs <= band[1])
+    return np.trapezoid(psd[band_mask], freqs[band_mask])
+
+# Resolve EEG stream
+print("Looking for an EEG stream...")
+streams = resolve_byprop('type', 'EEG', timeout=LSL_SCAN_TIMEOUT)
+if not streams:
+    raise RuntimeError("EEG Stream not found.")
+
+print("Started acquiring data.")
+inlet = StreamInlet(streams[0], max_chunklen=CHUNK_LENGTH)
+info = inlet.info()
+NCHAN = info.channel_count()
+CH_NAMES = ['TP9', 'AF7', 'AF8', 'TP10', 'AUX'][:NCHAN]
+
+def collect_data(recording_time=30):
+    """
+    Collect EEG data from the LSL stream for a specified duration.
+    
+    This function collects EEG data from the connected LSL stream for the specified
+    recording time. It pulls data chunks from the stream and accumulates them into
+    arrays for further processing.
+    
+    Args:
+        recording_time (float, optional): Duration to collect data in seconds. Defaults to 30.
+    
+    Returns:
+        tuple: A tuple containing:
+            - numpy.ndarray: Collected EEG data with shape (channels, samples)
+            - numpy.ndarray: Timestamps for each sample
+    
+    Example:
+        ```python
+        # Collect 5 seconds of EEG data
+        eeg_data, timestamps = collect_data(recording_time=5)
+        print(f"Collected {eeg_data.shape[1]} samples from {eeg_data.shape[0]} channels")
+        ```
+    """
+    start_time = time.time()
+    all_data, all_timestamps = [], []
+    while time.time() - start_time < recording_time:
+        data, timestamps = inlet.pull_chunk(timeout=0.1, max_samples=CHUNK_LENGTH)
+        if timestamps:
+            all_data.extend(data)
+            all_timestamps.extend(timestamps)
+    return np.array(all_data).T, np.array(all_timestamps)
+
+def process_data(all_data):
+    """
+    Process EEG data to extract frequency band powers.
+    
+    This function processes the collected EEG data by dividing it into overlapping
+    windows and computing the power in each frequency band (theta, alpha, beta, gamma, etc.)
+    for each window.
+    
+    Args:
+        all_data (numpy.ndarray): EEG data with shape (channels, samples)
+    
+    Returns:
+        dict: A dictionary where keys are frequency band names and values are lists of
+              band powers for each window
+    
+    Example:
+        ```python
+        # Process collected EEG data
+        eeg_data, _ = collect_data(recording_time=5)
+        band_powers = process_data(eeg_data)
+        print(f"Alpha band powers: {band_powers['alpha']}")
+        ```
+    """
+    band_levels = {key: [] for key in BANDS}
+    for start in range(0, all_data.shape[1] - WINDOW_SIZE, STEP_SIZE):
+        window_data = all_data[:, start:start + WINDOW_SIZE]
+        for band_name, band_range in BANDS.items():
+            band_levels[band_name].append(
+                np.mean([compute_band_power(ch_data, FS, band_range) for ch_data in window_data])
+            )
+    return band_levels
+
+def compute_focus_index(theta, alpha, beta):
+    """
+    Compute a focus/attention index based on EEG frequency band powers.
+    
+    This function calculates a focus index by taking the ratio of beta power to the
+    sum of alpha and theta powers. Higher values indicate higher focus/attention levels.
+    
+    Args:
+        theta (list or numpy.ndarray): Theta band powers
+        alpha (list or numpy.ndarray): Alpha band powers
+        beta (list or numpy.ndarray): Beta band powers
+    
+    Returns:
+        list: Focus index values for each input data point
+    
+    Example:
+        ```python
+        # Compute focus index from band powers
+        eeg_data, _ = collect_data(recording_time=5)
+        band_powers = process_data(eeg_data)
+        focus_index = compute_focus_index(
+            band_powers['theta'], 
+            band_powers['alpha'], 
+            band_powers['beta']
+        )
+        print(f"Focus index: {focus_index}")
+        ```
+    """
+    epsilon = 1e-6  # Avoid division by zero
+    return (np.array(beta) / (np.array(alpha) + np.array(theta) + epsilon)).tolist()
+
+# Thresholds (adjust as needed)
+THRESHOLD_GAMMA = 8
+THRESHOLD_SIXTY = 250
+
+# Live Plotting
+timestamps, focus_levels, target_focus_levels = [], [], []
+start_time = time.time()
+focus_or_not = True
+while True:
+    focus_or_not = not focus_or_not
+    for _ in range(15):
+        target_focus = 14 if focus_or_not else 5
+        current_time = time.time() - start_time
+        
+        # Collect and process data
+        new_data, new_timestamps = collect_data(2)
+        band_levels = process_data(new_data)
+        focus_level = np.mean(band_levels["gamma"])
+        
+        # Determine shared variable
+        focus_val = 2 if focus_level > THRESHOLD_GAMMA * 2 else 1 if focus_level > THRESHOLD_GAMMA else 0
+        print(focus_val)
+        
+        # Update plot data
+        timestamps.append(current_time)
+        focus_levels.append(focus_level)
+        target_focus_levels.append(target_focus)
+        
+        # Clear and redraw plot
+        clear_output(wait=True)
+        fig, axes = plt.subplots(2, 1, figsize=(10, 4))
+        
+        # Focus Level Plot
+        axes[0].plot(timestamps, focus_levels, label="Focus Level")
+        axes[0].plot(timestamps, target_focus_levels, label="Target Focus Level", linestyle='dashed')
+        axes[0].set_xlabel("Time (s)")
+        axes[0].set_ylabel("Focus Level")
+        axes[0].legend()
+        axes[0].set_title("Focus Level Over Time")
+        
+        # EEG Data Plot
+        for i in range(NCHAN):
+            axes[1].plot(new_timestamps - new_timestamps[0], new_data[i] + i * 100, label=CH_NAMES[i])
+        
+        axes[1].set_xlabel("Time (s)")
+        axes[1].set_ylabel("EEG Signal")
+        axes[1].set_title("EEG Data Over 10 Seconds")
+        axes[1].legend()
+        
+        plt.tight_layout()
+        plt.show()
+
+
+# In[ ]:
+
+
+import nest_asyncio
+import uvicorn
+import threading
+from fastapi import FastAPI
+import asyncio
+
+# Apply nest_asyncio to allow running FastAPI inside Jupyter
+nest_asyncio.apply()
+
+app = FastAPI()
+
+# Global variable to be updated
+shared_var = 0
+
+# Async function to simulate real-time updates
+async def update_var():
+    """
+    Asynchronous function to update shared variables in real-time.
+    
+    This function runs in the background and periodically updates shared variables
+    that can be accessed by FastAPI endpoints. It's designed to run as a background
+    task in the FastAPI application.
+    
+    Note:
+        The function is currently configured to sleep for 1 second between updates,
+        but the actual update logic is commented out.
+    
+    Example:
+        ```python
+        # Start the update task in the background
+        asyncio.create_task(update_var())
+        ```
+    """
+    global shared_var
+    while True:
+        await asyncio.sleep(1)  # Update every second
+        #shared_var += 1
+
+@app.get("/latest_value")
+async def get_latest_value():
+    """
+    FastAPI endpoint to return the latest focus value.
+    
+    This endpoint returns the current focus value calculated from the EEG data.
+    It can be accessed via HTTP GET request to /latest_value.
+    
+    Returns:
+        dict: A dictionary containing the current focus value
+              - shared_var (int): The current focus value (0, 1, or 2)
+    
+    Example:
+        ```python
+        import requests
+        
+        response = requests.get("http://127.0.0.1:8000/latest_value")
+        print(response.json())  # {"shared_var": 1}
+        ```
+    """
+    return {"shared_var": focus_val}
+
+@app.on_event("startup")
+async def startup():
+    """
+    Function that runs when the FastAPI application starts up.
+    
+    This function is called when the FastAPI application starts. It initializes
+    background tasks like the update_var function.
+    
+    Example:
+        This function is automatically called by FastAPI when the application starts.
+        It doesn't need to be called manually.
+    """
+    asyncio.create_task(update_var())
+
+def run_server():
+    """
+    Function to run the FastAPI server.
+    
+    This function starts the Uvicorn server to serve the FastAPI application.
+    It's designed to be run in a separate thread to avoid blocking the main thread.
+    
+    Example:
+        ```python
+        # Run the server in a separate thread
+        import threading
+        server_thread = threading.Thread(target=run_server, daemon=True)
+        server_thread.start()
+        ```
+    """
+    uvicorn.run(app, host="127.0.0.1", port=8000)
+
+# Run the server in a separate thread so it doesn't block Jupyter
+server_thread = threading.Thread(target=run_server, daemon=True)
+server_thread.start()
+
diff --git a/requirements.txt b/requirements.txt
new file mode 100644
index 0000000..ea41541
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,29 @@
+# Backend dependencies
+fastapi==0.95.1
+uvicorn==0.22.0
+pydantic==1.10.7
+
+# EEG processing dependencies
+numpy==1.24.3
+matplotlib==3.7.1
+scipy==1.10.1
+pylsl==1.16.0
+
+# Language model dependencies
+torch==2.0.0
+transformers==4.28.1
+tqdm==4.65.0
+accelerate==0.19.0
+bitsandbytes==0.37.2
+huggingface_hub==0.14.1
+
+# Testing dependencies
+pytest==7.3.1
+requests==2.30.0
+
+# Optional: For real EEG data
+# muselsl>=2.0.0
+
+# Interactive demo dependencies
+keyboard==0.13.5
+nest_asyncio==1.5.6
diff --git a/setup.py b/setup.py
new file mode 100644
index 0000000..b3514bf
--- /dev/null
+++ b/setup.py
@@ -0,0 +1,31 @@
+from setuptools import setup, find_packages
+
+with open("README.md", "r", encoding="utf-8") as fh:
+    long_description = fh.read()
+
+with open("requirements.txt", "r", encoding="utf-8") as f:
+    requirements = f.read().splitlines()
+
+setup(
+    name="eeg_enhanced_lm",
+    version="0.1.0",
+    author="Contributors",
+    author_email="your.email@example.com",
+    description="EEG-Enhanced Language Model with Mixture-of-Experts",
+    long_description=long_description,
+    long_description_content_type="text/markdown",
+    url="https://github.com/yourusername/hackathon-mercor-etched-cognition",
+    packages=find_packages(),
+    classifiers=[
+        "Programming Language :: Python :: 3",
+        "License :: OSI Approved :: MIT License",
+        "Operating System :: OS Independent",
+    ],
+    python_requires=">=3.8",
+    install_requires=requirements,
+    entry_points={
+        "console_scripts": [
+            "eeg-lm-demo=kevin_moe_demo.demo:main",
+        ],
+    },
+)
diff --git a/tests/backend/test_main.py b/tests/backend/test_main.py
new file mode 100644
index 0000000..1e80936
--- /dev/null
+++ b/tests/backend/test_main.py
@@ -0,0 +1,217 @@
+"""
+Unit tests for the FastAPI backend application.
+
+These tests cover the API endpoints and functionality of the backend server.
+"""
+
+import json
+import pytest
+from fastapi.testclient import TestClient
+from unittest.mock import patch, MagicMock
+
+# Import the FastAPI app
+import sys
+import os
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../backend')))
+from main import app, token_queue, EXPERT_COLORS
+
+# Create a test client
+client = TestClient(app)
+
+# Test data
+test_tokens = [
+    {"token": "Hello", "expert": "simple"},
+    {"token": " ", "expert": "balanced"},
+    {"token": "world", "expert": "complex"}
+]
+
+
+class TestBackendEndpoints:
+    """Test class for backend API endpoints."""
+
+    def setup_method(self):
+        """Set up test environment before each test."""
+        # Clear the token queue before each test
+        token_queue.clear()
+
+    def test_add_tokens_endpoint(self):
+        """Test the /add-tokens endpoint."""
+        # Prepare test data
+        data = {"tokens": test_tokens}
+        
+        # Send POST request to add tokens
+        response = client.post("/add-tokens", json=data)
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json() == {"status": "success", "tokens_added": 3}
+        
+        # Check that tokens were added to the queue
+        assert len(token_queue) == 3
+        assert token_queue[0]["word"] == "Hello"
+        assert token_queue[0]["number"] == EXPERT_COLORS["simple"]
+        assert token_queue[1]["word"] == " "
+        assert token_queue[1]["number"] == EXPERT_COLORS["balanced"]
+        assert token_queue[2]["word"] == "world"
+        assert token_queue[2]["number"] == EXPERT_COLORS["complex"]
+
+    def test_add_tokens_with_empty_tokens(self):
+        """Test the /add-tokens endpoint with empty tokens."""
+        # Prepare test data with empty tokens
+        data = {"tokens": []}
+        
+        # Send POST request to add tokens
+        response = client.post("/add-tokens", json=data)
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json() == {"status": "success", "tokens_added": 0}
+        
+        # Check that no tokens were added to the queue
+        assert len(token_queue) == 0
+
+    def test_add_tokens_with_invalid_tokens(self):
+        """Test the /add-tokens endpoint with invalid tokens."""
+        # Prepare test data with invalid tokens (missing required fields)
+        data = {"tokens": [{"token": "Hello"}]}  # Missing 'expert' field
+        
+        # Send POST request to add tokens
+        response = client.post("/add-tokens", json=data)
+        
+        # Check response (should be a validation error)
+        assert response.status_code == 422  # Unprocessable Entity
+
+    def test_clear_tokens_endpoint(self):
+        """Test the /clear-tokens endpoint."""
+        # Add some tokens to the queue
+        token_queue.extend([
+            {"word": "Hello", "number": 1},
+            {"word": "world", "number": 3}
+        ])
+        
+        # Send POST request to clear tokens
+        response = client.post("/clear-tokens")
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json() == {"status": "success", "message": "Token queue cleared"}
+        
+        # Check that the queue is empty
+        assert len(token_queue) == 0
+
+    def test_toggle_test_data_endpoint(self):
+        """Test the /toggle-test-data endpoint."""
+        # Send POST request to enable test data
+        response = client.post("/toggle-test-data", json={"enable": True})
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json() == {"status": "success", "test_data_enabled": True}
+        
+        # Send POST request to disable test data
+        response = client.post("/toggle-test-data", json={"enable": False})
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json() == {"status": "success", "test_data_enabled": False}
+
+    def test_get_status_endpoint(self):
+        """Test the /status endpoint."""
+        # Add some tokens to the queue
+        token_queue.extend([
+            {"word": "Hello", "number": 1},
+            {"word": "world", "number": 3}
+        ])
+        
+        # Send GET request to get status
+        response = client.get("/status")
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json()["queue_size"] == 2
+        assert "test_data_enabled" in response.json()
+
+    def test_debug_tokens_endpoint(self):
+        """Test the /debug-tokens endpoint."""
+        # Add some tokens to the queue
+        token_queue.extend([
+            {"word": "Hello", "number": 1},
+            {"word": "world", "number": 3}
+        ])
+        
+        # Send GET request to get debug tokens
+        response = client.get("/debug-tokens")
+        
+        # Check response
+        assert response.status_code == 200
+        assert response.json()["queue_size"] == 2
+        assert len(response.json()["tokens"]) == 2
+        assert "test_data_enabled" in response.json()
+        
+        # Test with limit parameter
+        response = client.get("/debug-tokens?limit=1")
+        assert response.status_code == 200
+        assert len(response.json()["tokens"]) == 1
+
+    @pytest.mark.asyncio
+    async def test_stream_endpoint(self):
+        """Test the /stream endpoint."""
+        # This test is more complex because it involves server-sent events
+        # We'll use a mock to test the event_stream function
+        
+        with patch('main.event_stream') as mock_event_stream:
+            # Set up the mock to return a sequence of events
+            mock_event_stream.return_value = [
+                f"data: {json.dumps({'word': 'Hello', 'number': 1})}\n\n",
+                f"data: {json.dumps({'word': 'world', 'number': 3})}\n\n"
+            ]
+            
+            # Send GET request to stream endpoint
+            response = client.get("/stream")
+            
+            # Check response
+            assert response.status_code == 200
+            assert response.headers["content-type"] == "text/event-stream"
+            
+            # Check that event_stream was called
+            mock_event_stream.assert_called_once()
+
+
+class TestRandomTokenGeneration:
+    """Test class for random token generation functionality."""
+
+    def test_generate_random_token(self):
+        """Test the generate_random_token function."""
+        from main import generate_random_token
+        
+        # Generate a random token
+        token = generate_random_token()
+        
+        # Check that the token has the expected structure
+        assert "word" in token
+        assert "number" in token
+        assert isinstance(token["word"], str)
+        assert isinstance(token["number"], int)
+        assert 1 <= token["number"] <= 3  # Expert color should be 1, 2, or 3
+
+    def test_generate_test_tokens(self):
+        """Test the generate_test_tokens function."""
+        from main import generate_test_tokens
+        
+        # Generate test tokens
+        tokens = generate_test_tokens()
+        
+        # Check that tokens were generated
+        assert len(tokens) >= 1
+        
+        # Check that each token has the expected structure
+        for token in tokens:
+            assert hasattr(token, "token")
+            assert hasattr(token, "expert")
+            assert isinstance(token.token, str)
+            assert isinstance(token.expert, str)
+            assert token.expert in ["simple", "balanced", "complex"]
+
+
+if __name__ == "__main__":
+    pytest.main(["-v", __file__])
diff --git a/tests/backend/test_token_processing.py b/tests/backend/test_token_processing.py
new file mode 100644
index 0000000..2ab4caa
--- /dev/null
+++ b/tests/backend/test_token_processing.py
@@ -0,0 +1,256 @@
+"""
+Unit tests for token processing functionality in the backend.
+
+These tests cover the token processing logic, including token validation,
+expert color mapping, and token queue management.
+"""
+
+import pytest
+from collections import deque
+import json
+import asyncio
+from unittest.mock import patch, MagicMock, AsyncMock
+
+# Import the backend modules
+import sys
+import os
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../backend')))
+from main import EXPERT_COLORS, token_queue, add_tokens, event_stream, TokenData, TokenStreamData
+
+# Test data
+test_tokens = [
+    TokenData(token="Hello", expert="simple"),
+    TokenData(token=" ", expert="balanced"),
+    TokenData(token="world", expert="complex")
+]
+
+
+class TestTokenProcessing:
+    """Test class for token processing functionality."""
+
+    def setup_method(self):
+        """Set up test environment before each test."""
+        # Clear the token queue before each test
+        token_queue.clear()
+
+    def test_expert_color_mapping(self):
+        """Test the expert to color mapping."""
+        # Check that each expert is mapped to the correct color
+        assert EXPERT_COLORS["simple"] == 1
+        assert EXPERT_COLORS["balanced"] == 2
+        assert EXPERT_COLORS["complex"] == 3
+        assert EXPERT_COLORS["unknown"] == 2  # Default to balanced/middle color
+
+    def test_token_validation_and_processing(self):
+        """Test token validation and processing logic."""
+        # Create a TokenStreamData object with test tokens
+        token_stream_data = TokenStreamData(tokens=test_tokens)
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that tokens were processed correctly
+        assert len(token_queue) == 3
+        
+        # Check the first token
+        assert token_queue[0]["word"] == "Hello"
+        assert token_queue[0]["number"] == EXPERT_COLORS["simple"]
+        
+        # Check the second token (space)
+        assert token_queue[1]["word"] == " "
+        assert token_queue[1]["number"] == EXPERT_COLORS["balanced"]
+        
+        # Check the third token
+        assert token_queue[2]["word"] == "world"
+        assert token_queue[2]["number"] == EXPERT_COLORS["complex"]
+
+    def test_token_validation_with_empty_token(self):
+        """Test token validation with empty token."""
+        # Create a TokenStreamData object with an empty token
+        token_stream_data = TokenStreamData(tokens=[TokenData(token="", expert="simple")])
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that the empty token was not added to the queue
+        assert len(token_queue) == 0
+
+    def test_token_validation_with_space_token(self):
+        """Test token validation with space token."""
+        # Create a TokenStreamData object with a space token
+        token_stream_data = TokenStreamData(tokens=[TokenData(token=" ", expert="simple")])
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that the space token was added to the queue
+        assert len(token_queue) == 1
+        assert token_queue[0]["word"] == " "
+        assert token_queue[0]["number"] == EXPERT_COLORS["simple"]
+
+    def test_token_validation_with_long_token(self):
+        """Test token validation with a long token."""
+        # Create a TokenStreamData object with a long token
+        long_token = "a" * 50
+        token_stream_data = TokenStreamData(tokens=[TokenData(token=long_token, expert="simple")])
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that the long token was truncated
+        assert len(token_queue) == 1
+        assert token_queue[0]["word"] == "a" * 27 + "..."
+        assert token_queue[0]["number"] == EXPERT_COLORS["simple"]
+
+    def test_token_validation_with_special_characters(self):
+        """Test token validation with special characters."""
+        # Create a TokenStreamData object with tokens containing special characters
+        special_tokens = [
+            TokenData(token="Hello\nWorld", expert="simple"),  # Newline
+            TokenData(token="Hello\tWorld", expert="balanced"),  # Tab
+            TokenData(token="Hello\\World", expert="complex")  # Backslash
+        ]
+        token_stream_data = TokenStreamData(tokens=special_tokens)
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that special characters were handled correctly
+        assert len(token_queue) == 3
+        assert token_queue[0]["word"] == "Hello World"  # Newline replaced with space
+        assert token_queue[1]["word"] == "Hello World"  # Tab replaced with space
+        assert token_queue[2]["word"] == "Hello\\\\World"  # Backslash escaped
+
+    def test_token_validation_with_unknown_expert(self):
+        """Test token validation with unknown expert."""
+        # Create a TokenStreamData object with an unknown expert
+        token_stream_data = TokenStreamData(tokens=[TokenData(token="Hello", expert="unknown_expert")])
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that the token was added with the default expert color
+        assert len(token_queue) == 1
+        assert token_queue[0]["word"] == "Hello"
+        assert token_queue[0]["number"] == EXPERT_COLORS["unknown"]  # Default to unknown color
+
+    def test_token_queue_maxlen(self):
+        """Test token queue maximum length."""
+        # Add more tokens than the maximum queue length
+        max_len = token_queue.maxlen
+        
+        # Create a large number of tokens
+        many_tokens = [TokenData(token=f"Token{i}", expert="simple") for i in range(max_len + 10)]
+        token_stream_data = TokenStreamData(tokens=many_tokens)
+        
+        # Process the tokens
+        add_tokens(token_stream_data)
+        
+        # Check that the queue length is limited to maxlen
+        assert len(token_queue) == max_len
+
+
+class TestEventStream:
+    """Test class for event stream functionality."""
+
+    def setup_method(self):
+        """Set up test environment before each test."""
+        # Clear the token queue before each test
+        token_queue.clear()
+
+    @pytest.mark.asyncio
+    async def test_event_stream_with_tokens(self):
+        """Test the event_stream function with tokens in the queue."""
+        # Add tokens to the queue
+        token_queue.extend([
+            {"word": "Hello", "number": 1},
+            {"word": "world", "number": 3}
+        ])
+        
+        # Create a mock for asyncio.sleep to avoid actual delays
+        with patch('asyncio.sleep', new_callable=AsyncMock) as mock_sleep:
+            # Get the event stream generator
+            generator = event_stream()
+            
+            # Get the first event
+            event = await generator.__anext__()
+            
+            # Check that the event has the expected format
+            assert event.startswith("data: ")
+            assert "Hello" in event
+            assert "1" in event
+            
+            # Check that sleep was called
+            mock_sleep.assert_called_once()
+            
+            # Reset the mock
+            mock_sleep.reset_mock()
+            
+            # Get the second event
+            event = await generator.__anext__()
+            
+            # Check that the event has the expected format
+            assert event.startswith("data: ")
+            assert "world" in event
+            assert "3" in event
+            
+            # Check that sleep was called
+            mock_sleep.assert_called_once()
+
+    @pytest.mark.asyncio
+    async def test_event_stream_with_empty_queue(self):
+        """Test the event_stream function with an empty queue."""
+        # Create a mock for asyncio.sleep to avoid actual delays
+        with patch('asyncio.sleep', new_callable=AsyncMock) as mock_sleep:
+            # Get the event stream generator
+            generator = event_stream()
+            
+            # Set enable_test_data to False to avoid generating random tokens
+            import main
+            main.enable_test_data = False
+            
+            # Try to get an event (should sleep and not yield anything)
+            # We'll use a timeout to avoid hanging
+            try:
+                await asyncio.wait_for(generator.__anext__(), timeout=0.1)
+                assert False, "Should have timed out"
+            except asyncio.TimeoutError:
+                pass
+            
+            # Check that sleep was called
+            mock_sleep.assert_called_once()
+
+    @pytest.mark.asyncio
+    async def test_event_stream_with_test_data(self):
+        """Test the event_stream function with test data enabled."""
+        # Create a mock for asyncio.sleep to avoid actual delays
+        with patch('asyncio.sleep', new_callable=AsyncMock) as mock_sleep:
+            # Create a mock for generate_random_token
+            with patch('main.generate_random_token') as mock_generate_random_token:
+                # Set up the mock to return a test token
+                mock_generate_random_token.return_value = {"word": "TestToken", "number": 2}
+                
+                # Get the event stream generator
+                generator = event_stream()
+                
+                # Set enable_test_data to True to generate random tokens
+                import main
+                main.enable_test_data = True
+                
+                # Get the first event
+                event = await generator.__anext__()
+                
+                # Check that the event has the expected format
+                assert event.startswith("data: ")
+                assert "TestToken" in event
+                assert "2" in event
+                
+                # Check that generate_random_token was called
+                mock_generate_random_token.assert_called_once()
+                
+                # Check that sleep was called
+                mock_sleep.assert_called_once()
+
+
+if __name__ == "__main__":
+    pytest.main(["-v", __file__])
diff --git a/tests/eeg/test_eeg_processing.py b/tests/eeg/test_eeg_processing.py
new file mode 100644
index 0000000..40a000f
--- /dev/null
+++ b/tests/eeg/test_eeg_processing.py
@@ -0,0 +1,292 @@
+"""
+Unit tests for EEG signal processing functionality.
+
+These tests cover the EEG signal processing functions, including band power computation,
+data collection, and data processing.
+"""
+
+import pytest
+import numpy as np
+from unittest.mock import patch, MagicMock, Mock
+import sys
+import os
+
+# Add the eeg directory to the Python path
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../eeg')))
+
+# Import the EEG processing functions
+from eeg import compute_band_power, collect_data, process_data, BANDS, FS, WINDOW_SIZE, STEP_SIZE
+
+
+class TestBandPowerComputation:
+    """Test class for band power computation."""
+
+    def test_compute_band_power_theta(self):
+        """Test computing power in the theta band."""
+        # Create synthetic EEG data with known frequency components
+        # Theta band: 4-7 Hz
+        t = np.linspace(0, 1, FS)  # 1 second of data at FS sampling rate
+        theta_signal = np.sin(2 * np.pi * 5 * t)  # 5 Hz sine wave (in theta band)
+        
+        # Compute band power
+        theta_power = compute_band_power(theta_signal, FS, BANDS["theta"])
+        
+        # The power should be significant in the theta band
+        assert theta_power > 0.1
+        
+        # Test with a signal outside the theta band
+        alpha_signal = np.sin(2 * np.pi * 10 * t)  # 10 Hz sine wave (in alpha band)
+        alpha_in_theta_power = compute_band_power(alpha_signal, FS, BANDS["theta"])
+        
+        # The power should be very low in the theta band
+        assert alpha_in_theta_power < 0.1
+        
+        # The theta signal should have more power in the theta band than the alpha signal
+        assert theta_power > alpha_in_theta_power
+
+    def test_compute_band_power_alpha(self):
+        """Test computing power in the alpha band."""
+        # Create synthetic EEG data with known frequency components
+        # Alpha band: 8-13 Hz
+        t = np.linspace(0, 1, FS)  # 1 second of data at FS sampling rate
+        alpha_signal = np.sin(2 * np.pi * 10 * t)  # 10 Hz sine wave (in alpha band)
+        
+        # Compute band power
+        alpha_power = compute_band_power(alpha_signal, FS, BANDS["alpha"])
+        
+        # The power should be significant in the alpha band
+        assert alpha_power > 0.1
+        
+        # Test with a signal outside the alpha band
+        beta_signal = np.sin(2 * np.pi * 20 * t)  # 20 Hz sine wave (in beta band)
+        beta_in_alpha_power = compute_band_power(beta_signal, FS, BANDS["alpha"])
+        
+        # The power should be very low in the alpha band
+        assert beta_in_alpha_power < 0.1
+        
+        # The alpha signal should have more power in the alpha band than the beta signal
+        assert alpha_power > beta_in_alpha_power
+
+    def test_compute_band_power_beta(self):
+        """Test computing power in the beta band."""
+        # Create synthetic EEG data with known frequency components
+        # Beta band: 14-30 Hz
+        t = np.linspace(0, 1, FS)  # 1 second of data at FS sampling rate
+        beta_signal = np.sin(2 * np.pi * 20 * t)  # 20 Hz sine wave (in beta band)
+        
+        # Compute band power
+        beta_power = compute_band_power(beta_signal, FS, BANDS["beta"])
+        
+        # The power should be significant in the beta band
+        assert beta_power > 0.1
+        
+        # Test with a signal outside the beta band
+        gamma_signal = np.sin(2 * np.pi * 40 * t)  # 40 Hz sine wave (in gamma band)
+        gamma_in_beta_power = compute_band_power(gamma_signal, FS, BANDS["beta"])
+        
+        # The power should be very low in the beta band
+        assert gamma_in_beta_power < 0.1
+        
+        # The beta signal should have more power in the beta band than the gamma signal
+        assert beta_power > gamma_in_beta_power
+
+    def test_compute_band_power_gamma(self):
+        """Test computing power in the gamma band."""
+        # Create synthetic EEG data with known frequency components
+        # Gamma band: 31-50 Hz
+        t = np.linspace(0, 1, FS)  # 1 second of data at FS sampling rate
+        gamma_signal = np.sin(2 * np.pi * 40 * t)  # 40 Hz sine wave (in gamma band)
+        
+        # Compute band power
+        gamma_power = compute_band_power(gamma_signal, FS, BANDS["gamma"])
+        
+        # The power should be significant in the gamma band
+        assert gamma_power > 0.1
+        
+        # Test with a signal outside the gamma band
+        beta_signal = np.sin(2 * np.pi * 20 * t)  # 20 Hz sine wave (in beta band)
+        beta_in_gamma_power = compute_band_power(beta_signal, FS, BANDS["gamma"])
+        
+        # The power should be very low in the gamma band
+        assert beta_in_gamma_power < 0.1
+        
+        # The gamma signal should have more power in the gamma band than the beta signal
+        assert gamma_power > beta_in_gamma_power
+
+    def test_compute_band_power_mixed_signal(self):
+        """Test computing band power with a mixed signal."""
+        # Create a mixed signal with multiple frequency components
+        t = np.linspace(0, 1, FS)  # 1 second of data at FS sampling rate
+        theta_component = 0.5 * np.sin(2 * np.pi * 5 * t)  # 5 Hz (theta)
+        alpha_component = 1.0 * np.sin(2 * np.pi * 10 * t)  # 10 Hz (alpha)
+        beta_component = 0.3 * np.sin(2 * np.pi * 20 * t)  # 20 Hz (beta)
+        gamma_component = 0.1 * np.sin(2 * np.pi * 40 * t)  # 40 Hz (gamma)
+        
+        mixed_signal = theta_component + alpha_component + beta_component + gamma_component
+        
+        # Compute band powers
+        theta_power = compute_band_power(mixed_signal, FS, BANDS["theta"])
+        alpha_power = compute_band_power(mixed_signal, FS, BANDS["alpha"])
+        beta_power = compute_band_power(mixed_signal, FS, BANDS["beta"])
+        gamma_power = compute_band_power(mixed_signal, FS, BANDS["gamma"])
+        
+        # Check that the band powers reflect the signal composition
+        # Alpha should have the highest power (amplitude 1.0)
+        # Theta should be next (amplitude 0.5)
+        # Beta should be next (amplitude 0.3)
+        # Gamma should be lowest (amplitude 0.1)
+        assert alpha_power > theta_power
+        assert theta_power > beta_power
+        assert beta_power > gamma_power
+
+
+class TestDataCollection:
+    """Test class for EEG data collection."""
+
+    @patch('eeg.inlet')
+    def test_collect_data(self, mock_inlet):
+        """Test collecting EEG data from the LSL stream."""
+        # Mock the inlet.pull_chunk method to return synthetic data
+        mock_data = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]
+        mock_timestamps = [0.0, 0.1, 0.2]
+        mock_inlet.pull_chunk.return_value = (mock_data, mock_timestamps)
+        
+        # Call collect_data with a short recording time
+        data, timestamps = collect_data(recording_time=0.1)
+        
+        # Check that pull_chunk was called
+        mock_inlet.pull_chunk.assert_called()
+        
+        # Check that the data was transposed correctly
+        assert data.shape[0] == 2  # 2 channels
+        assert data.shape[1] == 3  # 3 samples
+        assert np.array_equal(data[0], [0.1, 0.2, 0.3])
+        assert np.array_equal(data[1], [0.4, 0.5, 0.6])
+        
+        # Check that the timestamps were returned correctly
+        assert np.array_equal(timestamps, [0.0, 0.1, 0.2])
+
+    @patch('eeg.inlet')
+    def test_collect_data_empty(self, mock_inlet):
+        """Test collecting EEG data when no data is available."""
+        # Mock the inlet.pull_chunk method to return empty data
+        mock_inlet.pull_chunk.return_value = ([], [])
+        
+        # Call collect_data with a short recording time
+        data, timestamps = collect_data(recording_time=0.1)
+        
+        # Check that pull_chunk was called
+        mock_inlet.pull_chunk.assert_called()
+        
+        # Check that empty arrays were returned
+        assert data.shape == (0, 0)
+        assert timestamps.shape == (0,)
+
+    @patch('eeg.inlet')
+    def test_collect_data_multiple_chunks(self, mock_inlet):
+        """Test collecting EEG data with multiple chunks."""
+        # Mock the inlet.pull_chunk method to return different data on each call
+        mock_inlet.pull_chunk.side_effect = [
+            ([[0.1, 0.2], [0.3, 0.4]], [0.0, 0.1]),
+            ([[0.5, 0.6], [0.7, 0.8]], [0.2, 0.3]),
+            ([], [])  # End of data
+        ]
+        
+        # Call collect_data with a longer recording time
+        data, timestamps = collect_data(recording_time=0.5)
+        
+        # Check that pull_chunk was called multiple times
+        assert mock_inlet.pull_chunk.call_count > 1
+        
+        # Check that the data was combined correctly
+        assert data.shape[0] == 2  # 2 channels
+        assert data.shape[1] == 4  # 4 samples
+        assert np.array_equal(data[0], [0.1, 0.2, 0.5, 0.6])
+        assert np.array_equal(data[1], [0.3, 0.4, 0.7, 0.8])
+        
+        # Check that the timestamps were combined correctly
+        assert np.array_equal(timestamps, [0.0, 0.1, 0.2, 0.3])
+
+
+class TestDataProcessing:
+    """Test class for EEG data processing."""
+
+    @patch('eeg.compute_band_power')
+    def test_process_data(self, mock_compute_band_power):
+        """Test processing EEG data to extract frequency band powers."""
+        # Mock the compute_band_power function to return known values
+        mock_compute_band_power.side_effect = lambda data, fs, band: {
+            (4, 7): 0.1,    # theta
+            (8, 13): 0.2,   # alpha
+            (14, 30): 0.3,  # beta
+            (31, 50): 0.4,  # gamma
+            (55, 65): 0.5   # sixty
+        }[band]
+        
+        # Create synthetic EEG data
+        # 2 channels, 1000 samples (enough for multiple windows)
+        data = np.random.rand(2, 1000)
+        
+        # Process the data
+        band_levels = process_data(data)
+        
+        # Check that compute_band_power was called
+        assert mock_compute_band_power.call_count > 0
+        
+        # Check that band_levels has the expected structure
+        assert set(band_levels.keys()) == set(BANDS.keys())
+        
+        # Check that each band has the expected number of values
+        # Number of windows = (data.shape[1] - WINDOW_SIZE) / STEP_SIZE + 1
+        expected_windows = (data.shape[1] - WINDOW_SIZE) // STEP_SIZE + 1
+        for band_name in BANDS:
+            assert len(band_levels[band_name]) == expected_windows
+        
+        # Check that the band levels have the expected values
+        for band_name in BANDS:
+            expected_value = {
+                "theta": 0.1,
+                "alpha": 0.2,
+                "beta": 0.3,
+                "gamma": 0.4,
+                "sixty": 0.5
+            }[band_name]
+            
+            for value in band_levels[band_name]:
+                assert value == expected_value
+
+    def test_process_data_real(self):
+        """Test processing EEG data with real computation."""
+        # Create synthetic EEG data with known frequency components
+        t = np.linspace(0, 10, FS * 10)  # 10 seconds of data at FS sampling rate
+        
+        # Channel 1: Strong alpha (10 Hz)
+        ch1 = np.sin(2 * np.pi * 10 * t)
+        
+        # Channel 2: Strong beta (20 Hz)
+        ch2 = np.sin(2 * np.pi * 20 * t)
+        
+        # Combine channels
+        data = np.vstack((ch1, ch2))
+        
+        # Process the data
+        band_levels = process_data(data)
+        
+        # Check that band_levels has the expected structure
+        assert set(band_levels.keys()) == set(BANDS.keys())
+        
+        # Check that the alpha band has higher power than other bands
+        # (since we have a strong 10 Hz component)
+        for i in range(len(band_levels["alpha"])):
+            assert band_levels["alpha"][i] > band_levels["theta"][i]
+            assert band_levels["alpha"][i] > band_levels["gamma"][i]
+        
+        # Check that the beta band also has significant power
+        # (since we have a strong 20 Hz component)
+        for i in range(len(band_levels["beta"])):
+            assert band_levels["beta"][i] > band_levels["theta"][i]
+            assert band_levels["beta"][i] > band_levels["gamma"][i]
+
+
+if __name__ == "__main__":
+    pytest.main(["-v", __file__])
diff --git a/tests/eeg/test_focus_index.py b/tests/eeg/test_focus_index.py
new file mode 100644
index 0000000..63bc22b
--- /dev/null
+++ b/tests/eeg/test_focus_index.py
@@ -0,0 +1,210 @@
+"""
+Unit tests for focus index calculation in EEG processing.
+
+These tests cover the computation of focus/attention metrics from EEG frequency band powers.
+"""
+
+import pytest
+import numpy as np
+import sys
+import os
+
+# Add the eeg directory to the Python path
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../eeg')))
+
+# Import the focus index computation function
+from eeg import compute_focus_index
+
+
+class TestFocusIndexComputation:
+    """Test class for focus index computation."""
+
+    def test_compute_focus_index_basic(self):
+        """Test basic focus index computation."""
+        # Create test data
+        theta = [1.0, 2.0, 3.0]
+        alpha = [2.0, 3.0, 4.0]
+        beta = [6.0, 9.0, 12.0]
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index has the expected length
+        assert len(focus_index) == 3
+        
+        # Check that the focus index values are correct
+        # focus_index = beta / (alpha + theta)
+        expected = [6.0 / (1.0 + 2.0), 9.0 / (2.0 + 3.0), 12.0 / (3.0 + 4.0)]
+        for i in range(3):
+            assert focus_index[i] == pytest.approx(expected[i])
+
+    def test_compute_focus_index_zero_denominator(self):
+        """Test focus index computation with zero denominator."""
+        # Create test data with zero alpha and theta
+        theta = [0.0, 0.0, 0.0]
+        alpha = [0.0, 0.0, 0.0]
+        beta = [1.0, 2.0, 3.0]
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index has the expected length
+        assert len(focus_index) == 3
+        
+        # Check that the focus index values are finite (not infinity)
+        # The function should handle division by zero
+        for value in focus_index:
+            assert np.isfinite(value)
+            assert value > 0  # Should be positive
+
+    def test_compute_focus_index_high_focus(self):
+        """Test focus index computation with high focus (high beta, low alpha/theta)."""
+        # Create test data for high focus
+        theta = [0.5, 0.6, 0.7]
+        alpha = [0.8, 0.9, 1.0]
+        beta = [10.0, 12.0, 14.0]
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index values are high
+        for value in focus_index:
+            assert value > 5.0  # Arbitrary threshold for "high" focus
+
+    def test_compute_focus_index_low_focus(self):
+        """Test focus index computation with low focus (low beta, high alpha/theta)."""
+        # Create test data for low focus
+        theta = [5.0, 6.0, 7.0]
+        alpha = [8.0, 9.0, 10.0]
+        beta = [1.0, 1.2, 1.4]
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index values are low
+        for value in focus_index:
+            assert value < 0.2  # Arbitrary threshold for "low" focus
+
+    def test_compute_focus_index_numpy_arrays(self):
+        """Test focus index computation with NumPy arrays."""
+        # Create test data as NumPy arrays
+        theta = np.array([1.0, 2.0, 3.0])
+        alpha = np.array([2.0, 3.0, 4.0])
+        beta = np.array([6.0, 9.0, 12.0])
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index has the expected length
+        assert len(focus_index) == 3
+        
+        # Check that the focus index values are correct
+        expected = [6.0 / (1.0 + 2.0), 9.0 / (2.0 + 3.0), 12.0 / (3.0 + 4.0)]
+        for i in range(3):
+            assert focus_index[i] == pytest.approx(expected[i])
+
+    def test_compute_focus_index_empty_input(self):
+        """Test focus index computation with empty input."""
+        # Create empty test data
+        theta = []
+        alpha = []
+        beta = []
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index is empty
+        assert len(focus_index) == 0
+
+    def test_compute_focus_index_different_lengths(self):
+        """Test focus index computation with inputs of different lengths."""
+        # Create test data with different lengths
+        theta = [1.0, 2.0]
+        alpha = [2.0, 3.0, 4.0]
+        beta = [6.0, 9.0, 12.0, 15.0]
+        
+        # This should raise a ValueError or similar
+        with pytest.raises(Exception):
+            compute_focus_index(theta, alpha, beta)
+
+    def test_compute_focus_index_negative_values(self):
+        """Test focus index computation with negative values."""
+        # Create test data with negative values
+        theta = [-1.0, 2.0, 3.0]
+        alpha = [2.0, -3.0, 4.0]
+        beta = [6.0, 9.0, -12.0]
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index has the expected length
+        assert len(focus_index) == 3
+        
+        # The function should handle negative values
+        # The exact behavior depends on the implementation
+        # Here we just check that the values are finite
+        for value in focus_index:
+            assert np.isfinite(value)
+
+
+class TestFocusIndexInterpretation:
+    """Test class for focus index interpretation."""
+
+    def test_focus_index_thresholds(self):
+        """Test focus index thresholds for different attention levels."""
+        # Define thresholds for different attention levels
+        LOW_THRESHOLD = 0.5
+        HIGH_THRESHOLD = 2.0
+        
+        # Create test data for different attention levels
+        low_focus = 0.3
+        medium_focus = 1.0
+        high_focus = 3.0
+        
+        # Check that the thresholds correctly classify the attention levels
+        assert low_focus < LOW_THRESHOLD  # Low attention
+        assert LOW_THRESHOLD <= medium_focus < HIGH_THRESHOLD  # Medium attention
+        assert high_focus >= HIGH_THRESHOLD  # High attention
+
+    def test_focus_index_time_series(self):
+        """Test focus index computation for a time series."""
+        # Create a time series of band powers
+        # Simulate increasing focus over time
+        time_points = 10
+        theta = np.linspace(3.0, 1.0, time_points)  # Decreasing theta
+        alpha = np.linspace(4.0, 2.0, time_points)  # Decreasing alpha
+        beta = np.linspace(6.0, 12.0, time_points)  # Increasing beta
+        
+        # Compute focus index
+        focus_index = compute_focus_index(theta, alpha, beta)
+        
+        # Check that the focus index increases over time
+        for i in range(1, time_points):
+            assert focus_index[i] > focus_index[i-1]
+
+    def test_focus_index_stability(self):
+        """Test focus index stability with small variations in band powers."""
+        # Create base band powers
+        theta_base = 2.0
+        alpha_base = 3.0
+        beta_base = 9.0
+        
+        # Compute base focus index
+        base_focus = beta_base / (theta_base + alpha_base)
+        
+        # Create variations of the band powers
+        variations = 10
+        theta_var = np.random.normal(theta_base, 0.1, variations)
+        alpha_var = np.random.normal(alpha_base, 0.1, variations)
+        beta_var = np.random.normal(beta_base, 0.1, variations)
+        
+        # Compute focus index for variations
+        focus_var = compute_focus_index(theta_var, alpha_var, beta_var)
+        
+        # Check that the variations are within a reasonable range of the base focus
+        for focus in focus_var:
+            assert abs(focus - base_focus) < 0.5  # Arbitrary threshold
+
+
+if __name__ == "__main__":
+    pytest.main(["-v", __file__])
diff --git a/tests/frontend/test_app.js b/tests/frontend/test_app.js
new file mode 100644
index 0000000..8b329d8
--- /dev/null
+++ b/tests/frontend/test_app.js
@@ -0,0 +1,392 @@
+/**
+ * Unit tests for the React frontend application.
+ * 
+ * These tests cover the rendering and functionality of the React components.
+ */
+
+import React from 'react';
+import { render, screen, fireEvent, waitFor } from '@testing-library/react';
+import '@testing-library/jest-dom';
+import App from '../../frontend/src/App';
+import { StreamingApp } from '../../frontend/src/App';
+import { getColor } from '../../frontend/src/utils/colorMapping';
+
+// Mock the EventSource API
+class MockEventSource {
+  constructor(url) {
+    this.url = url;
+    this.onmessage = null;
+    this.onerror = null;
+    this.onopen = null;
+    this.readyState = 0; // 0 = CONNECTING, 1 = OPEN, 2 = CLOSED
+    
+    // Simulate connection
+    setTimeout(() => {
+      this.readyState = 1;
+      if (this.onopen) this.onopen();
+    }, 100);
+  }
+  
+  // Method to simulate receiving a message
+  simulateMessage(data) {
+    if (this.onmessage) {
+      const event = { data: JSON.stringify(data) };
+      this.onmessage(event);
+    }
+  }
+  
+  // Method to simulate an error
+  simulateError() {
+    if (this.onerror) {
+      this.onerror(new Error('EventSource error'));
+    }
+  }
+  
+  // Method to close the connection
+  close() {
+    this.readyState = 2;
+  }
+}
+
+// Mock the fetch API
+global.fetch = jest.fn();
+
+// Mock the EventSource API
+global.EventSource = MockEventSource;
+
+describe('App Component', () => {
+  beforeEach(() => {
+    // Reset mocks before each test
+    jest.clearAllMocks();
+    
+    // Mock successful fetch response
+    global.fetch.mockResolvedValue({
+      ok: true,
+      json: async () => ({ status: 'success' })
+    });
+  });
+  
+  test('renders without crashing', () => {
+    render(<App />);
+    expect(screen.getByText(/EEG-Enhanced Language Model/i)).toBeInTheDocument();
+  });
+  
+  test('renders the StreamingApp component', () => {
+    render(<App />);
+    expect(screen.getByTestId('streaming-app')).toBeInTheDocument();
+  });
+  
+  test('renders the header with the correct title', () => {
+    render(<App />);
+    expect(screen.getByRole('heading', { name: /EEG-Enhanced Language Model/i })).toBeInTheDocument();
+  });
+  
+  test('renders the footer with the correct text', () => {
+    render(<App />);
+    expect(screen.getByText(/¬© 2023 EEG-Enhanced Language Model/i)).toBeInTheDocument();
+  });
+});
+
+describe('StreamingApp Component', () => {
+  let mockEventSource;
+  
+  beforeEach(() => {
+    // Reset mocks before each test
+    jest.clearAllMocks();
+    
+    // Mock successful fetch response
+    global.fetch.mockResolvedValue({
+      ok: true,
+      json: async () => ({ status: 'success' })
+    });
+    
+    // Render the component
+    render(<StreamingApp />);
+    
+    // Get the mock EventSource instance
+    mockEventSource = new MockEventSource('http://localhost:8000/stream');
+  });
+  
+  test('renders the output container', () => {
+    expect(screen.getByTestId('output-container')).toBeInTheDocument();
+  });
+  
+  test('renders the control buttons', () => {
+    expect(screen.getByText(/Clear/i)).toBeInTheDocument();
+    expect(screen.getByText(/Test Data/i)).toBeInTheDocument();
+  });
+  
+  test('clicking Clear button calls clearTokens', async () => {
+    // Click the Clear button
+    fireEvent.click(screen.getByText(/Clear/i));
+    
+    // Check that fetch was called with the correct URL and method
+    expect(global.fetch).toHaveBeenCalledWith(
+      'http://localhost:8000/clear-tokens',
+      { method: 'POST' }
+    );
+    
+    // Wait for the success message
+    await waitFor(() => {
+      expect(screen.getByText(/Tokens cleared/i)).toBeInTheDocument();
+    });
+  });
+  
+  test('clicking Test Data button calls toggleTestData', async () => {
+    // Click the Test Data button
+    fireEvent.click(screen.getByText(/Test Data/i));
+    
+    // Check that fetch was called with the correct URL, method, and body
+    expect(global.fetch).toHaveBeenCalledWith(
+      'http://localhost:8000/toggle-test-data',
+      {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({ enable: true })
+      }
+    );
+    
+    // Wait for the success message
+    await waitFor(() => {
+      expect(screen.getByText(/Test data enabled/i)).toBeInTheDocument();
+    });
+    
+    // Click the Test Data button again to disable
+    fireEvent.click(screen.getByText(/Test Data/i));
+    
+    // Check that fetch was called with the correct URL, method, and body
+    expect(global.fetch).toHaveBeenCalledWith(
+      'http://localhost:8000/toggle-test-data',
+      {
+        method: 'POST',
+        headers: { 'Content-Type': 'application/json' },
+        body: JSON.stringify({ enable: false })
+      }
+    );
+    
+    // Wait for the success message
+    await waitFor(() => {
+      expect(screen.getByText(/Test data disabled/i)).toBeInTheDocument();
+    });
+  });
+  
+  test('displays tokens received from the EventSource', async () => {
+    // Simulate receiving a message
+    mockEventSource.simulateMessage({ word: 'Hello', number: 1 });
+    
+    // Check that the token was added to the output container
+    await waitFor(() => {
+      const tokenElement = screen.getByText('Hello');
+      expect(tokenElement).toBeInTheDocument();
+      expect(tokenElement).toHaveClass('expert-1');
+    });
+    
+    // Simulate receiving another message
+    mockEventSource.simulateMessage({ word: ' world', number: 3 });
+    
+    // Check that the token was added to the output container
+    await waitFor(() => {
+      const tokenElement = screen.getByText(' world');
+      expect(tokenElement).toBeInTheDocument();
+      expect(tokenElement).toHaveClass('expert-3');
+    });
+  });
+  
+  test('handles EventSource errors', async () => {
+    // Simulate an error
+    mockEventSource.simulateError();
+    
+    // Check that the error message was displayed
+    await waitFor(() => {
+      expect(screen.getByText(/Error connecting to the server/i)).toBeInTheDocument();
+    });
+  });
+  
+  test('cleans up EventSource on unmount', () => {
+    // Create a spy on the EventSource.close method
+    const closeSpy = jest.spyOn(MockEventSource.prototype, 'close');
+    
+    // Unmount the component
+    const { unmount } = render(<StreamingApp />);
+    unmount();
+    
+    // Check that close was called
+    expect(closeSpy).toHaveBeenCalled();
+  });
+});
+
+describe('Token Display', () => {
+  beforeEach(() => {
+    // Reset mocks before each test
+    jest.clearAllMocks();
+    
+    // Mock successful fetch response
+    global.fetch.mockResolvedValue({
+      ok: true,
+      json: async () => ({ status: 'success' })
+    });
+    
+    // Render the component
+    render(<StreamingApp />);
+  });
+  
+  test('displays tokens with the correct color class', async () => {
+    // Get the mock EventSource instance
+    const mockEventSource = new MockEventSource('http://localhost:8000/stream');
+    
+    // Simulate receiving messages with different expert numbers
+    mockEventSource.simulateMessage({ word: 'Simple', number: 1 });
+    mockEventSource.simulateMessage({ word: ' balanced', number: 2 });
+    mockEventSource.simulateMessage({ word: ' complex', number: 3 });
+    
+    // Check that the tokens were added with the correct color classes
+    await waitFor(() => {
+      const simpleToken = screen.getByText('Simple');
+      expect(simpleToken).toHaveClass('expert-1');
+      
+      const balancedToken = screen.getByText(' balanced');
+      expect(balancedToken).toHaveClass('expert-2');
+      
+      const complexToken = screen.getByText(' complex');
+      expect(complexToken).toHaveClass('expert-3');
+    });
+  });
+  
+  test('handles tokens with special characters', async () => {
+    // Get the mock EventSource instance
+    const mockEventSource = new MockEventSource('http://localhost:8000/stream');
+    
+    // Simulate receiving a message with special characters
+    mockEventSource.simulateMessage({ word: 'Hello\nWorld', number: 1 });
+    
+    // Check that the token was added and displayed correctly
+    await waitFor(() => {
+      const tokenElement = screen.getByText('Hello\nWorld');
+      expect(tokenElement).toBeInTheDocument();
+    });
+  });
+  
+  test('handles empty tokens', async () => {
+    // Get the mock EventSource instance
+    const mockEventSource = new MockEventSource('http://localhost:8000/stream');
+    
+    // Simulate receiving an empty message
+    mockEventSource.simulateMessage({ word: '', number: 1 });
+    
+    // Check that the token was not added (or was added as an empty string)
+    // This is implementation-dependent, so we just check that the component didn't crash
+    await waitFor(() => {
+      expect(screen.getByTestId('output-container')).toBeInTheDocument();
+    });
+  });
+  
+  test('handles a large number of tokens', async () => {
+    // Get the mock EventSource instance
+    const mockEventSource = new MockEventSource('http://localhost:8000/stream');
+    
+    // Simulate receiving many messages
+    for (let i = 0; i < 100; i++) {
+      mockEventSource.simulateMessage({ word: `Token${i}`, number: (i % 3) + 1 });
+    }
+    
+    // Check that the component didn't crash
+    await waitFor(() => {
+      expect(screen.getByTestId('output-container')).toBeInTheDocument();
+    });
+    
+    // Check that at least some of the tokens were added
+    await waitFor(() => {
+      expect(screen.getByText('Token0')).toBeInTheDocument();
+      expect(screen.getByText('Token99')).toBeInTheDocument();
+    });
+  });
+});
+
+describe('Error Handling', () => {
+  beforeEach(() => {
+    // Reset mocks before each test
+    jest.clearAllMocks();
+  });
+  
+  test('handles fetch errors when clearing tokens', async () => {
+    // Mock a failed fetch response
+    global.fetch.mockRejectedValue(new Error('Network error'));
+    
+    // Render the component
+    render(<StreamingApp />);
+    
+    // Click the Clear button
+    fireEvent.click(screen.getByText(/Clear/i));
+    
+    // Check that the error message was displayed
+    await waitFor(() => {
+      expect(screen.getByText(/Error clearing tokens/i)).toBeInTheDocument();
+    });
+  });
+  
+  test('handles fetch errors when toggling test data', async () => {
+    // Mock a failed fetch response
+    global.fetch.mockRejectedValue(new Error('Network error'));
+    
+    // Render the component
+    render(<StreamingApp />);
+    
+    // Click the Test Data button
+    fireEvent.click(screen.getByText(/Test Data/i));
+    
+    // Check that the error message was displayed
+    await waitFor(() => {
+      expect(screen.getByText(/Error toggling test data/i)).toBeInTheDocument();
+    });
+  });
+  
+  test('handles non-OK fetch responses', async () => {
+    // Mock a non-OK fetch response
+    global.fetch.mockResolvedValue({
+      ok: false,
+      status: 500,
+      statusText: 'Internal Server Error'
+    });
+    
+    // Render the component
+    render(<StreamingApp />);
+    
+    // Click the Clear button
+    fireEvent.click(screen.getByText(/Clear/i));
+    
+    // Check that the error message was displayed
+    await waitFor(() => {
+      expect(screen.getByText(/Error: 500 Internal Server Error/i)).toBeInTheDocument();
+    });
+  });
+});
+
+describe('Accessibility', () => {
+  beforeEach(() => {
+    // Reset mocks before each test
+    jest.clearAllMocks();
+    
+    // Mock successful fetch response
+    global.fetch.mockResolvedValue({
+      ok: true,
+      json: async () => ({ status: 'success' })
+    });
+  });
+  
+  test('buttons have accessible names', () => {
+    render(<StreamingApp />);
+    
+    // Check that the buttons have accessible names
+    expect(screen.getByRole('button', { name: /Clear/i })).toBeInTheDocument();
+    expect(screen.getByRole('button', { name: /Test Data/i })).toBeInTheDocument();
+  });
+  
+  test('output container has appropriate ARIA attributes', () => {
+    render(<StreamingApp />);
+    
+    // Check that the output container has appropriate ARIA attributes
+    const outputContainer = screen.getByTestId('output-container');
+    expect(outputContainer).toHaveAttribute('aria-live', 'polite');
+    expect(outputContainer).toHaveAttribute('aria-atomic', 'false');
+  });
+});
diff --git a/tests/frontend/test_color_mapping.js b/tests/frontend/test_color_mapping.js
new file mode 100644
index 0000000..d99db45
--- /dev/null
+++ b/tests/frontend/test_color_mapping.js
@@ -0,0 +1,255 @@
+/**
+ * Unit tests for color mapping functionality in the frontend.
+ * 
+ * These tests cover the mapping of expert numbers to color classes.
+ */
+
+import { getColor } from '../../frontend/src/utils/colorMapping';
+
+describe('Color Mapping', () => {
+  test('maps expert number 1 to the simple expert color', () => {
+    const color = getColor(1);
+    expect(color).toBe('expert-1');
+  });
+  
+  test('maps expert number 2 to the balanced expert color', () => {
+    const color = getColor(2);
+    expect(color).toBe('expert-2');
+  });
+  
+  test('maps expert number 3 to the complex expert color', () => {
+    const color = getColor(3);
+    expect(color).toBe('expert-3');
+  });
+  
+  test('maps unknown expert numbers to the default color', () => {
+    const color = getColor(4);
+    expect(color).toBe('expert-default');
+  });
+  
+  test('maps negative expert numbers to the default color', () => {
+    const color = getColor(-1);
+    expect(color).toBe('expert-default');
+  });
+  
+  test('maps non-numeric expert values to the default color', () => {
+    const color = getColor('not a number');
+    expect(color).toBe('expert-default');
+  });
+  
+  test('maps null expert values to the default color', () => {
+    const color = getColor(null);
+    expect(color).toBe('expert-default');
+  });
+  
+  test('maps undefined expert values to the default color', () => {
+    const color = getColor(undefined);
+    expect(color).toBe('expert-default');
+  });
+});
+
+describe('Color CSS Classes', () => {
+  // Mock document.createElement to test CSS class properties
+  const originalCreateElement = document.createElement;
+  let mockElement;
+  
+  beforeEach(() => {
+    mockElement = {
+      style: {},
+      classList: {
+        add: jest.fn(),
+        remove: jest.fn(),
+        contains: jest.fn()
+      }
+    };
+    
+    document.createElement = jest.fn(() => mockElement);
+  });
+  
+  afterEach(() => {
+    document.createElement = originalCreateElement;
+  });
+  
+  test('expert-1 class applies the simple expert color', () => {
+    // Create a span element
+    const span = document.createElement('span');
+    
+    // Add the expert-1 class
+    span.classList.add('expert-1');
+    
+    // Check that the class was added
+    expect(span.classList.add).toHaveBeenCalledWith('expert-1');
+  });
+  
+  test('expert-2 class applies the balanced expert color', () => {
+    // Create a span element
+    const span = document.createElement('span');
+    
+    // Add the expert-2 class
+    span.classList.add('expert-2');
+    
+    // Check that the class was added
+    expect(span.classList.add).toHaveBeenCalledWith('expert-2');
+  });
+  
+  test('expert-3 class applies the complex expert color', () => {
+    // Create a span element
+    const span = document.createElement('span');
+    
+    // Add the expert-3 class
+    span.classList.add('expert-3');
+    
+    // Check that the class was added
+    expect(span.classList.add).toHaveBeenCalledWith('expert-3');
+  });
+  
+  test('expert-default class applies the default color', () => {
+    // Create a span element
+    const span = document.createElement('span');
+    
+    // Add the expert-default class
+    span.classList.add('expert-default');
+    
+    // Check that the class was added
+    expect(span.classList.add).toHaveBeenCalledWith('expert-default');
+  });
+});
+
+describe('Color Mapping Integration', () => {
+  // Mock document.createElement to test integration with DOM
+  const originalCreateElement = document.createElement;
+  let mockElement;
+  
+  beforeEach(() => {
+    mockElement = {
+      style: {},
+      classList: {
+        add: jest.fn(),
+        remove: jest.fn(),
+        contains: jest.fn()
+      }
+    };
+    
+    document.createElement = jest.fn(() => mockElement);
+  });
+  
+  afterEach(() => {
+    document.createElement = originalCreateElement;
+  });
+  
+  test('getColor function is used to apply the correct class', () => {
+    // Create a span element
+    const span = document.createElement('span');
+    
+    // Use getColor to get the class name for expert number 1
+    const className = getColor(1);
+    
+    // Add the class to the span
+    span.classList.add(className);
+    
+    // Check that the correct class was added
+    expect(span.classList.add).toHaveBeenCalledWith('expert-1');
+  });
+  
+  test('getColor function handles multiple calls with different expert numbers', () => {
+    // Create span elements
+    const span1 = document.createElement('span');
+    const span2 = document.createElement('span');
+    const span3 = document.createElement('span');
+    
+    // Use getColor to get the class names for different expert numbers
+    const className1 = getColor(1);
+    const className2 = getColor(2);
+    const className3 = getColor(3);
+    
+    // Add the classes to the spans
+    span1.classList.add(className1);
+    span2.classList.add(className2);
+    span3.classList.add(className3);
+    
+    // Check that the correct classes were added
+    expect(span1.classList.add).toHaveBeenCalledWith('expert-1');
+    expect(span2.classList.add).toHaveBeenCalledWith('expert-2');
+    expect(span3.classList.add).toHaveBeenCalledWith('expert-3');
+  });
+});
+
+describe('Color Mapping Performance', () => {
+  test('getColor function is efficient for repeated calls', () => {
+    // Measure the time to call getColor many times
+    const startTime = performance.now();
+    
+    for (let i = 0; i < 10000; i++) {
+      getColor(i % 4);
+    }
+    
+    const endTime = performance.now();
+    const duration = endTime - startTime;
+    
+    // The function should be very fast (less than 100ms for 10000 calls)
+    expect(duration).toBeLessThan(100);
+  });
+});
+
+describe('Color Mapping Edge Cases', () => {
+  test('getColor function handles floating-point expert numbers', () => {
+    // Test with floating-point numbers
+    expect(getColor(1.5)).toBe('expert-1');  // Should round down or truncate
+    expect(getColor(2.9)).toBe('expert-2');  // Should round down or truncate
+  });
+  
+  test('getColor function handles expert numbers as strings', () => {
+    // Test with numbers as strings
+    expect(getColor('1')).toBe('expert-1');
+    expect(getColor('2')).toBe('expert-2');
+    expect(getColor('3')).toBe('expert-3');
+    expect(getColor('4')).toBe('expert-default');
+  });
+  
+  test('getColor function handles expert numbers with leading/trailing spaces', () => {
+    // Test with numbers as strings with spaces
+    expect(getColor(' 1 ')).toBe('expert-1');
+    expect(getColor(' 2 ')).toBe('expert-2');
+    expect(getColor(' 3 ')).toBe('expert-3');
+  });
+  
+  test('getColor function handles expert numbers with non-numeric characters', () => {
+    // Test with numbers as strings with non-numeric characters
+    expect(getColor('1px')).toBe('expert-default');
+    expect(getColor('2em')).toBe('expert-default');
+    expect(getColor('3%')).toBe('expert-default');
+  });
+});
+
+describe('Color Mapping Accessibility', () => {
+  test('expert colors have sufficient contrast ratio', () => {
+    // This test would normally check the contrast ratio of the colors
+    // against the background color to ensure accessibility.
+    // Since we don't have access to the actual CSS, we'll just
+    // simulate this test.
+    
+    // Define the background color (assumed to be white)
+    const backgroundColor = '#FFFFFF';
+    
+    // Define the expert colors (these are just example values)
+    const expertColors = {
+      'expert-1': '#0000FF',  // Blue
+      'expert-2': '#00FF00',  // Green
+      'expert-3': '#FF0000',  // Red
+      'expert-default': '#000000'  // Black
+    };
+    
+    // Function to calculate contrast ratio (simplified)
+    const calculateContrastRatio = (color1, color2) => {
+      // This is a simplified version that doesn't actually calculate
+      // the contrast ratio, but just returns a value for testing
+      return 4.5;  // Minimum contrast ratio for WCAG AA compliance
+    };
+    
+    // Check that each expert color has sufficient contrast
+    for (const [className, color] of Object.entries(expertColors)) {
+      const contrastRatio = calculateContrastRatio(color, backgroundColor);
+      expect(contrastRatio).toBeGreaterThanOrEqual(4.5);
+    }
+  });
+});
diff --git a/tests/integration/test_backend_frontend.py b/tests/integration/test_backend_frontend.py
new file mode 100644
index 0000000..57db755
--- /dev/null
+++ b/tests/integration/test_backend_frontend.py
@@ -0,0 +1,398 @@
+"""
+Integration tests for the interaction between the backend and frontend components.
+
+These tests verify that the backend and frontend components work together correctly,
+focusing on token streaming, event handling, and data flow between the components.
+"""
+
+import pytest
+import requests
+import json
+import time
+import asyncio
+import threading
+from unittest.mock import patch, MagicMock
+import sys
+import os
+
+# Add the backend directory to the Python path
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../backend')))
+
+# Import the backend app
+from main import app, token_queue, add_tokens, TokenData, TokenStreamData
+
+# Import the test client
+from fastapi.testclient import TestClient
+
+# Create a test client
+client = TestClient(app)
+
+# Test data
+test_tokens = [
+    {"token": "Hello", "expert": "simple"},
+    {"token": " ", "expert": "balanced"},
+    {"token": "world", "expert": "complex"}
+]
+
+
+class TestBackendFrontendIntegration:
+    """Test class for backend-frontend integration."""
+
+    def setup_method(self):
+        """Set up test environment before each test."""
+        # Clear the token queue before each test
+        token_queue.clear()
+
+    def test_token_streaming_flow(self):
+        """Test the complete token streaming flow from backend to frontend."""
+        # 1. Add tokens to the backend
+        response = client.post("/add-tokens", json={"tokens": test_tokens})
+        assert response.status_code == 200
+        assert response.json()["tokens_added"] == 3
+
+        # 2. Start a streaming connection
+        # We'll use a separate thread to simulate the frontend's EventSource connection
+        received_tokens = []
+        stop_event = threading.Event()
+
+        def stream_tokens():
+            """Simulate the frontend's EventSource connection."""
+            with client.stream("GET", "/stream") as response:
+                # Check that the response has the correct headers
+                assert response.status_code == 200
+                assert response.headers["content-type"] == "text/event-stream"
+
+                # Read events from the stream
+                for line in response.iter_lines():
+                    if stop_event.is_set():
+                        break
+
+                    if line.startswith(b"data: "):
+                        # Parse the event data
+                        data = json.loads(line[6:].decode("utf-8"))
+                        received_tokens.append(data)
+
+                        # If we've received all the tokens, stop
+                        if len(received_tokens) >= 3:
+                            stop_event.set()
+                            break
+
+        # Start the streaming thread
+        stream_thread = threading.Thread(target=stream_tokens)
+        stream_thread.start()
+
+        # Wait for the thread to receive all tokens or timeout
+        stop_event.wait(timeout=5)
+        stream_thread.join(timeout=1)
+
+        # Check that we received all the tokens
+        assert len(received_tokens) == 3
+
+        # Check that the tokens were received in the correct order
+        assert received_tokens[0]["word"] == "Hello"
+        assert received_tokens[0]["number"] == 1  # simple expert
+        assert received_tokens[1]["word"] == " "
+        assert received_tokens[1]["number"] == 2  # balanced expert
+        assert received_tokens[2]["word"] == "world"
+        assert received_tokens[2]["number"] == 3  # complex expert
+
+    def test_clear_tokens_integration(self):
+        """Test clearing tokens and its effect on the stream."""
+        # 1. Add tokens to the backend
+        response = client.post("/add-tokens", json={"tokens": test_tokens})
+        assert response.status_code == 200
+        assert response.json()["tokens_added"] == 3
+
+        # 2. Clear the tokens
+        response = client.post("/clear-tokens")
+        assert response.status_code == 200
+        assert response.json()["status"] == "success"
+
+        # 3. Check that the token queue is empty
+        response = client.get("/status")
+        assert response.status_code == 200
+        assert response.json()["queue_size"] == 0
+
+        # 4. Start a streaming connection
+        # We'll use a separate thread to simulate the frontend's EventSource connection
+        received_tokens = []
+        stop_event = threading.Event()
+
+        def stream_tokens():
+            """Simulate the frontend's EventSource connection."""
+            with client.stream("GET", "/stream") as response:
+                # Check that the response has the correct headers
+                assert response.status_code == 200
+                assert response.headers["content-type"] == "text/event-stream"
+
+                # Read events from the stream for a short time
+                start_time = time.time()
+                for line in response.iter_lines():
+                    if stop_event.is_set() or time.time() - start_time > 1:
+                        break
+
+                    if line.startswith(b"data: "):
+                        # Parse the event data
+                        data = json.loads(line[6:].decode("utf-8"))
+                        received_tokens.append(data)
+
+        # Start the streaming thread
+        stream_thread = threading.Thread(target=stream_tokens)
+        stream_thread.start()
+
+        # Wait for a short time
+        time.sleep(1)
+        stop_event.set()
+        stream_thread.join(timeout=1)
+
+        # Check that we didn't receive any tokens
+        assert len(received_tokens) == 0
+
+    def test_test_data_integration(self):
+        """Test enabling test data and its effect on the stream."""
+        # 1. Enable test data
+        response = client.post("/toggle-test-data", json={"enable": True})
+        assert response.status_code == 200
+        assert response.json()["test_data_enabled"] == True
+
+        # 2. Start a streaming connection
+        # We'll use a separate thread to simulate the frontend's EventSource connection
+        received_tokens = []
+        stop_event = threading.Event()
+
+        def stream_tokens():
+            """Simulate the frontend's EventSource connection."""
+            with client.stream("GET", "/stream") as response:
+                # Check that the response has the correct headers
+                assert response.status_code == 200
+                assert response.headers["content-type"] == "text/event-stream"
+
+                # Read events from the stream
+                for line in response.iter_lines():
+                    if stop_event.is_set():
+                        break
+
+                    if line.startswith(b"data: "):
+                        # Parse the event data
+                        data = json.loads(line[6:].decode("utf-8"))
+                        received_tokens.append(data)
+
+                        # If we've received some tokens, stop
+                        if len(received_tokens) >= 5:
+                            stop_event.set()
+                            break
+
+        # Start the streaming thread
+        stream_thread = threading.Thread(target=stream_tokens)
+        stream_thread.start()
+
+        # Wait for the thread to receive some tokens or timeout
+        stop_event.wait(timeout=5)
+        stream_thread.join(timeout=1)
+
+        # Check that we received some tokens
+        assert len(received_tokens) > 0
+
+        # 3. Disable test data
+        response = client.post("/toggle-test-data", json={"enable": False})
+        assert response.status_code == 200
+        assert response.json()["test_data_enabled"] == False
+
+    def test_debug_tokens_integration(self):
+        """Test the debug tokens endpoint with tokens in the queue."""
+        # 1. Add tokens to the backend
+        response = client.post("/add-tokens", json={"tokens": test_tokens})
+        assert response.status_code == 200
+        assert response.json()["tokens_added"] == 3
+
+        # 2. Get debug tokens
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        assert response.json()["queue_size"] == 3
+        assert len(response.json()["tokens"]) == 3
+
+        # Check that the tokens are correct
+        tokens = response.json()["tokens"]
+        assert tokens[0]["word"] == "Hello"
+        assert tokens[0]["number"] == 1  # simple expert
+        assert tokens[1]["word"] == " "
+        assert tokens[1]["number"] == 2  # balanced expert
+        assert tokens[2]["word"] == "world"
+        assert tokens[2]["number"] == 3  # complex expert
+
+    def test_frontend_rendering_simulation(self):
+        """Simulate the frontend rendering of tokens from the backend."""
+        # This test simulates how the frontend would render tokens
+        # received from the backend.
+
+        # 1. Add tokens to the backend
+        response = client.post("/add-tokens", json={"tokens": test_tokens})
+        assert response.status_code == 200
+        assert response.json()["tokens_added"] == 3
+
+        # 2. Get the tokens from the debug endpoint
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        tokens = response.json()["tokens"]
+
+        # 3. Simulate the frontend rendering
+        # In a real frontend, this would be done with React components
+        rendered_html = ""
+        for token in tokens:
+            # Map the expert number to a CSS class
+            expert_class = f"expert-{token['number']}"
+            # Create a span element with the token text and expert class
+            rendered_html += f'<span class="{expert_class}">{token["word"]}</span>'
+
+        # Check that the rendered HTML contains all the tokens with the correct classes
+        assert '<span class="expert-1">Hello</span>' in rendered_html
+        assert '<span class="expert-2"> </span>' in rendered_html
+        assert '<span class="expert-3">world</span>' in rendered_html
+
+        # The complete rendered text should be "Hello world"
+        rendered_text = "".join(token["word"] for token in tokens)
+        assert rendered_text == "Hello world"
+
+
+class TestBackendFrontendErrorHandling:
+    """Test class for backend-frontend error handling."""
+
+    def test_invalid_token_format(self):
+        """Test handling of invalid token format."""
+        # Try to add tokens with invalid format
+        invalid_tokens = [
+            {"token": "Hello"},  # Missing expert field
+            {"expert": "simple"}  # Missing token field
+        ]
+        response = client.post("/add-tokens", json={"tokens": invalid_tokens})
+        assert response.status_code == 422  # Unprocessable Entity
+
+    def test_invalid_expert_value(self):
+        """Test handling of invalid expert value."""
+        # Try to add tokens with invalid expert value
+        invalid_tokens = [
+            {"token": "Hello", "expert": "invalid_expert"}
+        ]
+        response = client.post("/add-tokens", json={"tokens": invalid_tokens})
+        assert response.status_code == 200  # Should still accept it but use default expert
+
+        # Check that the token was added with the default expert
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        tokens = response.json()["tokens"]
+        assert tokens[0]["word"] == "Hello"
+        assert tokens[0]["number"] == 2  # Default to balanced/middle color
+
+    def test_empty_token_queue(self):
+        """Test streaming with an empty token queue."""
+        # Clear the token queue
+        response = client.post("/clear-tokens")
+        assert response.status_code == 200
+
+        # Start a streaming connection
+        # We'll use a separate thread to simulate the frontend's EventSource connection
+        received_tokens = []
+        stop_event = threading.Event()
+
+        def stream_tokens():
+            """Simulate the frontend's EventSource connection."""
+            with client.stream("GET", "/stream") as response:
+                # Check that the response has the correct headers
+                assert response.status_code == 200
+                assert response.headers["content-type"] == "text/event-stream"
+
+                # Read events from the stream for a short time
+                start_time = time.time()
+                for line in response.iter_lines():
+                    if stop_event.is_set() or time.time() - start_time > 1:
+                        break
+
+                    if line.startswith(b"data: "):
+                        # Parse the event data
+                        data = json.loads(line[6:].decode("utf-8"))
+                        received_tokens.append(data)
+
+        # Start the streaming thread
+        stream_thread = threading.Thread(target=stream_tokens)
+        stream_thread.start()
+
+        # Wait for a short time
+        time.sleep(1)
+        stop_event.set()
+        stream_thread.join(timeout=1)
+
+        # Check that we didn't receive any tokens
+        assert len(received_tokens) == 0
+
+    def test_concurrent_connections(self):
+        """Test multiple concurrent streaming connections."""
+        # Add tokens to the backend
+        response = client.post("/add-tokens", json={"tokens": test_tokens})
+        assert response.status_code == 200
+        assert response.json()["tokens_added"] == 3
+
+        # Start multiple streaming connections
+        # We'll use separate threads to simulate multiple frontend clients
+        received_tokens_1 = []
+        received_tokens_2 = []
+        stop_event_1 = threading.Event()
+        stop_event_2 = threading.Event()
+
+        def stream_tokens_1():
+            """Simulate the first frontend client."""
+            with client.stream("GET", "/stream") as response:
+                for line in response.iter_lines():
+                    if stop_event_1.is_set():
+                        break
+
+                    if line.startswith(b"data: "):
+                        data = json.loads(line[6:].decode("utf-8"))
+                        received_tokens_1.append(data)
+
+                        if len(received_tokens_1) >= 3:
+                            stop_event_1.set()
+                            break
+
+        def stream_tokens_2():
+            """Simulate the second frontend client."""
+            with client.stream("GET", "/stream") as response:
+                for line in response.iter_lines():
+                    if stop_event_2.is_set():
+                        break
+
+                    if line.startswith(b"data: "):
+                        data = json.loads(line[6:].decode("utf-8"))
+                        received_tokens_2.append(data)
+
+                        if len(received_tokens_2) >= 3:
+                            stop_event_2.set()
+                            break
+
+        # Start the streaming threads
+        stream_thread_1 = threading.Thread(target=stream_tokens_1)
+        stream_thread_2 = threading.Thread(target=stream_tokens_2)
+        stream_thread_1.start()
+        stream_thread_2.start()
+
+        # Wait for the threads to receive all tokens or timeout
+        stop_event_1.wait(timeout=5)
+        stop_event_2.wait(timeout=5)
+        stream_thread_1.join(timeout=1)
+        stream_thread_2.join(timeout=1)
+
+        # Check that both clients received all the tokens
+        assert len(received_tokens_1) == 3
+        assert len(received_tokens_2) == 3
+
+        # Check that the tokens were received in the correct order by both clients
+        for tokens in [received_tokens_1, received_tokens_2]:
+            assert tokens[0]["word"] == "Hello"
+            assert tokens[0]["number"] == 1  # simple expert
+            assert tokens[1]["word"] == " "
+            assert tokens[1]["number"] == 2  # balanced expert
+            assert tokens[2]["word"] == "world"
+            assert tokens[2]["number"] == 3  # complex expert
+
+
+if __name__ == "__main__":
+    pytest.main(["-v", __file__])
diff --git a/tests/integration/test_eeg_backend.py b/tests/integration/test_eeg_backend.py
new file mode 100644
index 0000000..dc32720
--- /dev/null
+++ b/tests/integration/test_eeg_backend.py
@@ -0,0 +1,418 @@
+"""
+Integration tests for the interaction between the EEG processing and backend components.
+
+These tests verify that the EEG processing and backend components work together correctly,
+focusing on attention level detection, expert selection, and token generation based on EEG signals.
+"""
+
+import pytest
+import numpy as np
+import json
+import time
+from unittest.mock import patch, MagicMock
+import sys
+import os
+
+# Add the necessary directories to the Python path
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../eeg')))
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../backend')))
+
+# Import the EEG processing functions
+from eeg import compute_band_power, process_data, compute_focus_index, BANDS, FS
+
+# Import the backend app
+from main import app, token_queue, add_tokens, TokenData, TokenStreamData
+
+# Import the test client
+from fastapi.testclient import TestClient
+
+# Create a test client
+client = TestClient(app)
+
+
+class TestEEGBackendIntegration:
+    """Test class for EEG-backend integration."""
+
+    def setup_method(self):
+        """Set up test environment before each test."""
+        # Clear the token queue before each test
+        token_queue.clear()
+
+    def _create_synthetic_eeg_data(self, theta_amp=0.5, alpha_amp=0.5, beta_amp=0.5, gamma_amp=0.5, duration=1.0, channels=4):
+        """Create synthetic EEG data with specified frequency band amplitudes."""
+        # Define parameters
+        fs = FS  # Sampling frequency
+        t = np.arange(0, duration, 1/fs)  # Time vector
+        n_samples = len(t)
+        
+        # Create frequency components
+        theta_wave = theta_amp * np.sin(2 * np.pi * 6 * t)  # 6 Hz (theta band)
+        alpha_wave = alpha_amp * np.sin(2 * np.pi * 10 * t)  # 10 Hz (alpha band)
+        beta_wave = beta_amp * np.sin(2 * np.pi * 20 * t)  # 20 Hz (beta band)
+        gamma_wave = gamma_amp * np.sin(2 * np.pi * 40 * t)  # 40 Hz (gamma band)
+        
+        # Combine frequency components
+        eeg_signal = theta_wave + alpha_wave + beta_wave + gamma_wave
+        
+        # Add some noise
+        noise = 0.1 * np.random.randn(n_samples)
+        eeg_signal += noise
+        
+        # Replicate for multiple channels
+        eeg_data = np.tile(eeg_signal, (channels, 1))
+        
+        return eeg_data
+
+    @patch('eeg.inlet')
+    def test_eeg_attention_to_expert_mapping(self, mock_inlet):
+        """Test mapping of EEG attention levels to expert selection."""
+        # 1. Create synthetic EEG data with known frequency components
+        # Create data for different attention levels
+        
+        # Low attention: high theta/alpha, low beta
+        low_attention_data = self._create_synthetic_eeg_data(
+            theta_amp=1.0,
+            alpha_amp=1.0,
+            beta_amp=0.2
+        )
+        
+        # Medium attention: balanced theta/alpha/beta
+        medium_attention_data = self._create_synthetic_eeg_data(
+            theta_amp=0.5,
+            alpha_amp=0.5,
+            beta_amp=0.5
+        )
+        
+        # High attention: low theta/alpha, high beta
+        high_attention_data = self._create_synthetic_eeg_data(
+            theta_amp=0.2,
+            alpha_amp=0.2,
+            beta_amp=1.0
+        )
+        
+        # 2. Process the EEG data to extract attention metrics
+        # Mock the inlet.pull_chunk method to return the synthetic data
+        mock_inlet.pull_chunk.side_effect = [
+            (low_attention_data.T.tolist(), [0.0] * low_attention_data.shape[1]),
+            (medium_attention_data.T.tolist(), [0.0] * medium_attention_data.shape[1]),
+            (high_attention_data.T.tolist(), [0.0] * high_attention_data.shape[1]),
+            ([], [])  # End of data
+        ]
+        
+        # Import the EEG processing function that would normally be called in a separate process
+        from eeg import collect_data
+        
+        # Collect and process the data for each attention level
+        low_attention_eeg, _ = collect_data(recording_time=0.1)
+        low_attention_bands = process_data(low_attention_eeg)
+        low_attention_focus = compute_focus_index(
+            low_attention_bands["theta"],
+            low_attention_bands["alpha"],
+            low_attention_bands["beta"]
+        )
+        
+        medium_attention_eeg, _ = collect_data(recording_time=0.1)
+        medium_attention_bands = process_data(medium_attention_eeg)
+        medium_attention_focus = compute_focus_index(
+            medium_attention_bands["theta"],
+            medium_attention_bands["alpha"],
+            medium_attention_bands["beta"]
+        )
+        
+        high_attention_eeg, _ = collect_data(recording_time=0.1)
+        high_attention_bands = process_data(high_attention_eeg)
+        high_attention_focus = compute_focus_index(
+            high_attention_bands["theta"],
+            high_attention_bands["alpha"],
+            high_attention_bands["beta"]
+        )
+        
+        # 3. Map attention levels to expert selection
+        # Define thresholds for attention levels
+        LOW_THRESHOLD = 0.5
+        HIGH_THRESHOLD = 2.0
+        
+        # Function to map focus index to expert
+        def map_focus_to_expert(focus_index):
+            if focus_index < LOW_THRESHOLD:
+                return "simple"
+            elif focus_index < HIGH_THRESHOLD:
+                return "balanced"
+            else:
+                return "complex"
+        
+        # Map each attention level to an expert
+        low_attention_expert = map_focus_to_expert(np.mean(low_attention_focus))
+        medium_attention_expert = map_focus_to_expert(np.mean(medium_attention_focus))
+        high_attention_expert = map_focus_to_expert(np.mean(high_attention_focus))
+        
+        # 4. Check that the mapping is correct
+        # Low attention should map to the simple expert
+        assert low_attention_expert == "simple"
+        
+        # Medium attention should map to the balanced expert
+        assert medium_attention_expert == "balanced"
+        
+        # High attention should map to the complex expert
+        assert high_attention_expert == "complex"
+        
+        # 5. Generate tokens based on the selected experts
+        # Create tokens for each attention level
+        tokens = [
+            TokenData(token="Low", expert=low_attention_expert),
+            TokenData(token=" attention", expert=low_attention_expert),
+            TokenData(token=" maps", expert=low_attention_expert),
+            TokenData(token=" to", expert=low_attention_expert),
+            TokenData(token=" simple", expert=low_attention_expert),
+            TokenData(token=". ", expert=medium_attention_expert),
+            TokenData(token="Medium", expert=medium_attention_expert),
+            TokenData(token=" attention", expert=medium_attention_expert),
+            TokenData(token=" maps", expert=medium_attention_expert),
+            TokenData(token=" to", expert=medium_attention_expert),
+            TokenData(token=" balanced", expert=medium_attention_expert),
+            TokenData(token=". ", expert=high_attention_expert),
+            TokenData(token="High", expert=high_attention_expert),
+            TokenData(token=" attention", expert=high_attention_expert),
+            TokenData(token=" maps", expert=high_attention_expert),
+            TokenData(token=" to", expert=high_attention_expert),
+            TokenData(token=" complex", expert=high_attention_expert),
+            TokenData(token=".", expert=high_attention_expert)
+        ]
+        
+        # Add the tokens to the backend
+        token_stream_data = TokenStreamData(tokens=tokens)
+        add_tokens(token_stream_data)
+        
+        # 6. Check that the tokens were added with the correct expert colors
+        # Get the tokens from the debug endpoint
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        debug_tokens = response.json()["tokens"]
+        
+        # Check that the tokens have the correct expert colors
+        # Simple expert (low attention) should have color 1
+        for i in range(5):
+            assert debug_tokens[i]["number"] == 1
+        
+        # Balanced expert (medium attention) should have color 2
+        for i in range(5, 11):
+            assert debug_tokens[i]["number"] == 2
+        
+        # Complex expert (high attention) should have color 3
+        for i in range(11, 18):
+            assert debug_tokens[i]["number"] == 3
+
+    def test_expert_color_mapping(self):
+        """Test mapping of experts to colors in the backend."""
+        # Add tokens with different experts
+        tokens = [
+            TokenData(token="Simple", expert="simple"),
+            TokenData(token="Balanced", expert="balanced"),
+            TokenData(token="Complex", expert="complex")
+        ]
+        add_tokens(TokenStreamData(tokens=tokens))
+        
+        # Check that the tokens were added with the correct colors
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        debug_tokens = response.json()["tokens"]
+        
+        # Check that we have 3 tokens
+        assert len(debug_tokens) == 3
+        
+        # Check that the tokens have the correct colors
+        assert debug_tokens[0]["word"] == "Simple"
+        assert debug_tokens[0]["number"] == 1  # simple expert color
+        
+        assert debug_tokens[1]["word"] == "Balanced"
+        assert debug_tokens[1]["number"] == 2  # balanced expert color
+        
+        assert debug_tokens[2]["word"] == "Complex"
+        assert debug_tokens[2]["number"] == 3  # complex expert color
+
+    def test_eeg_attention_simulation(self):
+        """Test simulation of EEG attention levels and their effect on token generation."""
+        # This test simulates how the EEG attention levels would affect token generation
+        # in the Kevin-MOE demo.
+        
+        # 1. Define the attention levels
+        attention_levels = ["low", "medium", "high"]
+        
+        # 2. Define the expert weights for each attention level
+        expert_weights = {
+            "low": {"simple": 0.7, "balanced": 0.2, "complex": 0.1},
+            "medium": {"simple": 0.2, "balanced": 0.6, "complex": 0.2},
+            "high": {"simple": 0.1, "balanced": 0.2, "complex": 0.7}
+        }
+        
+        # 3. Define a function to select an expert based on weights
+        def select_expert(weights):
+            experts = list(weights.keys())
+            probabilities = list(weights.values())
+            return np.random.choice(experts, p=probabilities)
+        
+        # 4. Generate tokens for each attention level
+        np.random.seed(42)  # For reproducibility
+        tokens = []
+        
+        # Generate 10 tokens for each attention level
+        for attention in attention_levels:
+            for i in range(10):
+                expert = select_expert(expert_weights[attention])
+                token = f"{attention}-{i}"
+                tokens.append(TokenData(token=token, expert=expert))
+        
+        # 5. Add the tokens to the backend
+        token_stream_data = TokenStreamData(tokens=tokens)
+        add_tokens(token_stream_data)
+        
+        # 6. Check that the tokens were added with the correct expert colors
+        # Get the tokens from the debug endpoint
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        debug_tokens = response.json()["tokens"]
+        
+        # Count the number of tokens for each expert and attention level
+        expert_counts = {
+            "low": {"simple": 0, "balanced": 0, "complex": 0},
+            "medium": {"simple": 0, "balanced": 0, "complex": 0},
+            "high": {"simple": 0, "balanced": 0, "complex": 0}
+        }
+        
+        for i, token in enumerate(debug_tokens):
+            attention = token["word"].split("-")[0]
+            expert_number = token["number"]
+            
+            if expert_number == 1:
+                expert_counts[attention]["simple"] += 1
+            elif expert_number == 2:
+                expert_counts[attention]["balanced"] += 1
+            elif expert_number == 3:
+                expert_counts[attention]["complex"] += 1
+        
+        # Check that the expert distribution roughly matches the weights
+        # (with some tolerance due to randomness)
+        for attention in attention_levels:
+            total = sum(expert_counts[attention].values())
+            for expert, weight in expert_weights[attention].items():
+                expected = weight * 10
+                actual = expert_counts[attention][expert]
+                # Allow for some deviation due to randomness
+                assert abs(actual - expected) <= 5, f"Expected {expected} {expert} tokens for {attention} attention, got {actual}"
+
+    def test_token_streaming(self):
+        """Test streaming of tokens from the backend."""
+        # Add tokens to the queue
+        tokens = [
+            TokenData(token="Hello", expert="simple"),
+            TokenData(token=" world", expert="complex")
+        ]
+        add_tokens(TokenStreamData(tokens=tokens))
+        
+        # Check that the tokens are in the queue
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        debug_tokens = response.json()["tokens"]
+        
+        # Check that we have 2 tokens
+        assert len(debug_tokens) == 2
+        
+        # Check that the tokens have the correct values
+        assert debug_tokens[0]["word"] == "Hello"
+        assert debug_tokens[0]["number"] == 1  # simple expert color
+        
+        assert debug_tokens[1]["word"] == " world"
+        assert debug_tokens[1]["number"] == 3  # complex expert color
+
+
+class TestMOEIntegration:
+    """Test class for Mixture-of-Experts integration."""
+
+    def setup_method(self):
+        """Set up test environment before each test."""
+        # Clear the token queue before each test
+        token_queue.clear()
+
+    def test_moe_routing(self):
+        """Test routing of tokens through different experts based on attention."""
+        # Define attention levels and corresponding experts
+        attention_levels = {
+            "low": "simple",
+            "medium": "balanced",
+            "high": "complex"
+        }
+        
+        # Generate tokens for each attention level
+        tokens = []
+        for attention, expert in attention_levels.items():
+            for i in range(5):
+                token = f"{attention}-token-{i}"
+                tokens.append(TokenData(token=token, expert=expert))
+        
+        # Add the tokens to the backend
+        token_stream_data = TokenStreamData(tokens=tokens)
+        add_tokens(token_stream_data)
+        
+        # Check that the tokens were added with the correct expert colors
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        debug_tokens = response.json()["tokens"]
+        
+        # Check that we have the expected number of tokens
+        assert len(debug_tokens) == 15
+        
+        # Check that the tokens have the correct expert colors
+        for i in range(5):
+            # Low attention tokens should have color 1 (simple expert)
+            assert debug_tokens[i]["word"].startswith("low")
+            assert debug_tokens[i]["number"] == 1
+            
+            # Medium attention tokens should have color 2 (balanced expert)
+            assert debug_tokens[i+5]["word"].startswith("medium")
+            assert debug_tokens[i+5]["number"] == 2
+            
+            # High attention tokens should have color 3 (complex expert)
+            assert debug_tokens[i+10]["word"].startswith("high")
+            assert debug_tokens[i+10]["number"] == 3
+
+    def test_moe_token_generation(self):
+        """Test generation of tokens by different experts."""
+        # Define the experts and their token generation characteristics
+        experts = {
+            "simple": {"vocabulary": ["simple", "easy", "basic"], "color": 1},
+            "balanced": {"vocabulary": ["balanced", "moderate", "average"], "color": 2},
+            "complex": {"vocabulary": ["complex", "advanced", "sophisticated"], "color": 3}
+        }
+        
+        # Generate tokens from each expert
+        tokens = []
+        for expert, properties in experts.items():
+            for word in properties["vocabulary"]:
+                tokens.append(TokenData(token=word, expert=expert))
+        
+        # Add the tokens to the backend
+        token_stream_data = TokenStreamData(tokens=tokens)
+        add_tokens(token_stream_data)
+        
+        # Check that the tokens were added with the correct expert colors
+        response = client.get("/debug-tokens")
+        assert response.status_code == 200
+        debug_tokens = response.json()["tokens"]
+        
+        # Check that we have the expected number of tokens
+        assert len(debug_tokens) == 9
+        
+        # Check that the tokens have the correct expert colors
+        for i, token in enumerate(debug_tokens):
+            word = token["word"]
+            number = token["number"]
+            
+            # Find which expert this word belongs to
+            for expert, properties in experts.items():
+                if word in properties["vocabulary"]:
+                    expected_color = properties["color"]
+                    assert number == expected_color, f"Expected color {expected_color} for word '{word}', got {number}"
+
+
+if __name__ == "__main__":
+    pytest.main(["-v", __file__])
